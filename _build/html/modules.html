<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5. Documentation &#8212; GCol 0.0.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css?v=34905f61" />
    <script src="_static/documentation_options.js?v=8c5712d9"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="4. Performance Analysis" href="performance/Performance.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="performance/Performance.html" title="4. Performance Analysis"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GCol 0.0.4 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5. </span>Documentation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="documentation">
<h1><span class="section-number">5. </span>Documentation<a class="headerlink" href="#documentation" title="Link to this heading">¶</a></h1>
<p>The following commands are available in the <code class="docutils literal notranslate"><span class="pre">gcol</span></code> graph coloring library. These are written in pure Python, which can be viewed by clicking the <code class="docutils literal notranslate"><span class="pre">source</span></code> links below.</p>
<span class="target" id="module-gcol.coloring"></span><dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.chromatic_index">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">chromatic_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#chromatic_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.chromatic_index" title="Link to this definition">¶</a></dt>
<dd><p>Returns the chromatic index of the graph <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>The chromatic index of a graph <span class="math notranslate nohighlight">\(G\)</span> is the minimum number of colors needed to color the edges so that no two adjacent edges have the same color (a pair of edges is considered adjacent if and only if they share a common endpoint). The chromatic index is commonly denoted by <span class="math notranslate nohighlight">\(\chi'(G)\)</span>. Equivalently, <span class="math notranslate nohighlight">\(\chi'(G)\)</span> is the minimum number of matchings needed to partition the edges of <span class="math notranslate nohighlight">\(G\)</span>. According to Vizing’s theorem <a class="reference internal" href="#ra25aefb91f4c-1" id="id1">[1]</a>, <span class="math notranslate nohighlight">\(\chi'(G)\)</span> is equal to either <span class="math notranslate nohighlight">\(\Delta(G)\)</span> or <span class="math notranslate nohighlight">\(\Delta(G) + 1\)</span>, where <span class="math notranslate nohighlight">\(\Delta(G)\)</span> is the maximum degree in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Determining the chromatic index of a graph is NP-hard. The approach used here is based on the backtracking algorithm of <a class="reference internal" href="#ra25aefb91f4c-2" id="id2">[2]</a>. This is exact but operates in exponential time. It is therefore only suitable for graphs that are small, or that have topologies suited to its search strategies.</p>
<p>In this implementation, edge colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span> and then passing <span class="math notranslate nohighlight">\(L(G)\)</span> to the <a class="reference internal" href="#gcol.coloring.chromatic_number" title="gcol.coloring.chromatic_number"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chromatic_number()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The chromatic index for this graph will be calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>A nonnegative integer that gives the chromatic index of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.chromatic_number" title="gcol.coloring.chromatic_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chromatic_number</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The backtracking approach used here is an implementation of the exact algorithm described in <a class="reference internal" href="#ra25aefb91f4c-2" id="id3">[2]</a>. It has exponential runtime and halts only when the chromatic index has been determined. Further details of this algorithm are given in the notes section of the <a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_coloring()</span></code></a> method.</p>
<p>The above algorithm is described in detail in <a class="reference internal" href="#ra25aefb91f4c-2" id="id4">[2]</a>. The c++ code used in <a class="reference internal" href="#ra25aefb91f4c-2" id="id5">[2]</a> and <a class="reference internal" href="#ra25aefb91f4c-3" id="id6">[3]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="ra25aefb91f4c-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Vizing’s Theorem &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Vizing%27s_theorem">https://en.wikipedia.org/wiki/Vizing%27s_theorem</a>&gt;</p>
</div>
<div class="citation" id="ra25aefb91f4c-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>,<a role="doc-backlink" href="#id4">3</a>,<a role="doc-backlink" href="#id5">4</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="ra25aefb91f4c-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">3</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chi</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">chromatic_index</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Chromatic index is&quot;</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
<span class="go">Chromatic index is 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.chromatic_number">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">chromatic_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#chromatic_number"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.chromatic_number" title="Link to this definition">¶</a></dt>
<dd><p>Returns the chromatic number of the graph <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>The chromatic number of a graph <span class="math notranslate nohighlight">\(G\)</span> is the minimum number of colors needed to color the nodes so that no two adjacent nodes have the same color. It is commonly denoted by <span class="math notranslate nohighlight">\(\chi(G)\)</span>. Equivalently, <span class="math notranslate nohighlight">\(\chi(G)\)</span> is the minimum number of independent sets needed to partition the nodes of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Determining the chromatic number is NP-hard. The approach used here is based on the backtracking algorithm of <a class="reference internal" href="#r4e9c76beed8c-1" id="id10">[1]</a>. This is exact but operates in exponential time. It is therefore only suitable for graphs that are small, or that have topologies suited to its search strategies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The chromatic number for this graph will be calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>A nonnegative integer that gives the chromatic number of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.chromatic_index" title="gcol.coloring.chromatic_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chromatic_index</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The backtracking approach used here is an implementation of the exact algorithm described in <a class="reference internal" href="#r4e9c76beed8c-1" id="id11">[1]</a>. It has exponential runtime and halts only when the chromatic number has been determined. Further details of this algorithm are given in the notes section of the <a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_coloring()</span></code></a> method.</p>
<p>The above algorithm is described in detail in <a class="reference internal" href="#r4e9c76beed8c-1" id="id12">[1]</a>. The c++ code used in <a class="reference internal" href="#r4e9c76beed8c-1" id="id13">[1]</a> and <a class="reference internal" href="#r4e9c76beed8c-2" id="id14">[2]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r4e9c76beed8c-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id10">1</a>,<a role="doc-backlink" href="#id11">2</a>,<a role="doc-backlink" href="#id12">3</a>,<a role="doc-backlink" href="#id13">4</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="r4e9c76beed8c-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">2</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chi</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">chromatic_number</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Chromatic number is&quot;</span><span class="p">,</span> <span class="n">chi</span><span class="p">)</span>
<span class="go">Chromatic number is 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.coloring_layout">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">coloring_layout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#coloring_layout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.coloring_layout" title="Link to this definition">¶</a></dt>
<dd><p>Arranges the nodes of the graph in a circle so that nodes of the same color are next to each other. This method is designed to be used with the <code class="docutils literal notranslate"><span class="pre">pos</span></code> argument in the drawing functions of NetworkX (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The graph we want to visualize.</p>
</dd>
<dt><strong>c</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>. Nodes with negative values are ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pos</strong><span class="classifier">dict</span></dt><dd><p>A dictionary of positions keyed by node.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.get_node_colors" title="gcol.coloring.get_node_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_node_colors</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.multipartite_layout" title="gcol.coloring.multipartite_layout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multipartite_layout</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">gcol</span><span class="o">.</span><span class="n">coloring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">node_color</span><span class="o">=</span><span class="n">gcol</span><span class="o">.</span><span class="n">get_node_colors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.edge_coloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">edge_coloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dsatur'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#edge_coloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.edge_coloring" title="Link to this definition">¶</a></dt>
<dd><p>Returns a coloring of a graph’s edges.</p>
<p>An edge coloring of a graph is an assignment of colors to edges so that adjacent edges have different colors (a pair of edges is considered adjacent if and only if they share a common endpoint). The aim is to use as few colors as possible. A set of edges assigned to the same color corresponds to a matching; hence the equivalent aim is to partition the graph’s edges into a minimum number of matchings.</p>
<p>The smallest number of colors needed for coloring the edges of a graph <span class="math notranslate nohighlight">\(G\)</span> is known as the graph’s chromatic index, denoted by <span class="math notranslate nohighlight">\(\chi'(G)\)</span>. Equivalently, <span class="math notranslate nohighlight">\(\chi'(G)\)</span> is the minimum number of matchings needed to partition the nodes of a simple graph <span class="math notranslate nohighlight">\(G\)</span>. According to Vizing’s theorem <a class="reference internal" href="#r5a82b104155e-1" id="id17">[1]</a>, <span class="math notranslate nohighlight">\(\chi'(G)\)</span> is either <span class="math notranslate nohighlight">\(\Delta(G)\)</span> or <span class="math notranslate nohighlight">\(\Delta(G) + 1\)</span>, where <span class="math notranslate nohighlight">\(\Delta(G)\)</span> is the maximum degree in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Determining an edge coloring that minimizes the number of colors is an NP-hard problem. This method therefore includes options for using an exponential-time exact algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for graphs that are small, or that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</p>
<p>In this implementation, edge colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span>, and then passing <span class="math notranslate nohighlight">\(L(G)\)</span> to the <a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_coloring()</span></code></a> method. All parameters are therefore the same as the latter. (Note that, if a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> has <span class="math notranslate nohighlight">\(n\)</span> nodes and <span class="math notranslate nohighlight">\(m\)</span> edges, its line graph <span class="math notranslate nohighlight">\(L(G)\)</span> will have <span class="math notranslate nohighlight">\(m\)</span> nodes and <span class="math notranslate nohighlight">\(\frac{1}{2}\sum_{v\in V}\deg(v)^2 - m\)</span> edges.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The edges of this graph will be colored.</p>
</dd>
<dt><strong>strategy: string, optional (default=’dsatur’)</strong></dt><dd><p>A string specifying the method used to generate the initial solution. It must be one of the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'random'</span></code> : Randomly orders <span class="math notranslate nohighlight">\(L(G)\)</span>’s nodes and then applies the greedy algorithm for graph node coloring <a class="reference internal" href="#r5a82b104155e-2" id="id18">[2]</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'welsh-powell'</span></code> : Orders <span class="math notranslate nohighlight">\(L(G)\)</span>’s nodes by decreasing degree, then applies the greedy algorithm.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dsatur'</span></code> : Uses the DSatur algorithm for graph node coloring on <span class="math notranslate nohighlight">\(L(G)\)</span> <a class="reference internal" href="#r5a82b104155e-3" id="id19">[3]</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'rlf'</span></code> : Uses the recursive largest first (RLF) algorithm for graph node coloring on <span class="math notranslate nohighlight">\(L(G)\)</span> <a class="reference internal" href="#r5a82b104155e-4" id="id20">[4]</a>.</p></li>
</ul>
</dd>
<dt><strong>opt_alg</strong><span class="classifier">None or int, optional (default=None)</span></dt><dd><p>An integer specifying the optimization method that will be used to try to reduce the number of colors. It must be one of the following</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when an optimal solution has been found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes in <span class="math notranslate nohighlight">\(L(G)\)</span> to have the same color. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in <span class="math notranslate nohighlight">\(L(G)\)</span>, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges in <span class="math notranslate nohighlight">\(L(G)\)</span>, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors in the current solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes in <span class="math notranslate nohighlight">\(L(G)\)</span> to be uncolored. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, as above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> : No optimization is performed.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Only applicable when using <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>. The number of colors being used in a solution <code class="docutils literal notranslate"><span class="pre">c</span></code> is therefore <code class="docutils literal notranslate"><span class="pre">max(c.values())</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strategy</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">opt_alg</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.chromatic_index" title="gcol.coloring.chromatic_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chromatic_index</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.edge_k_coloring" title="gcol.coloring.edge_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_k_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>As mentioned, in this implementation, edge colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span> and then passing <span class="math notranslate nohighlight">\(L(G)\)</span> to the <a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_coloring()</span></code></a> method. All details are therefore the same as those in the latter, where they are documented more fully.</p>
<p>All the above algorithms and bounds are described in detail in <a class="reference internal" href="#r5a82b104155e-5" id="id21">[5]</a>. The c++ code used in <a class="reference internal" href="#r5a82b104155e-5" id="id22">[5]</a> and <a class="reference internal" href="#r5a82b104155e-6" id="id23">[6]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r5a82b104155e-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">1</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Vizing’s Theorem &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Vizing%27s_theorem">https://en.wikipedia.org/wiki/Vizing%27s_theorem</a>&gt;</p>
</div>
<div class="citation" id="r5a82b104155e-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">2</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Greedy Coloring &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Greedy_coloring">https://en.wikipedia.org/wiki/Greedy_coloring</a>&gt;</p>
</div>
<div class="citation" id="r5a82b104155e-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">3</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: DSatur &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/DSatur">https://en.wikipedia.org/wiki/DSatur</a>&gt;</p>
</div>
<div class="citation" id="r5a82b104155e-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">4</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Recursive largest first (RLF) algorithm &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm">https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm</a>&gt;</p>
</div>
<div class="citation" id="r5a82b104155e-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id21">1</a>,<a role="doc-backlink" href="#id22">2</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="r5a82b104155e-6" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">6</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">edge_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coloring is&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">Coloring is {(11, 12): 0, (11, 18): 1, (10, 11): 2, (12, 16): 1, (12, 13): 2, (18, 19): 0, (17, 18): 2, (16, 17): 0, (4, 17): 1, (15, 16): 2, (0, 10): 0, (9, 10): 1, (9, 13): 0, (8, 9): 2, (13, 14): 1, (14, 15): 0, (5, 15): 1, (7, 14): 2, (0, 19): 1, (3, 19): 2, (0, 1): 2, (3, 4): 0, (2, 3): 1, (1, 2): 0, (2, 6): 2, (5, 6): 0, (4, 5): 2, (1, 8): 1, (6, 7): 1, (7, 8): 0}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of colors =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Number of colors = 3</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">edge_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;rlf&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coloring is&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">Coloring is {(3, 4): 0, (17, 18): 0, (0, 19): 0, (10, 11): 0, (12, 16): 0, (5, 15): 0, (13, 14): 0, (8, 9): 0, (1, 2): 0, (6, 7): 0, (16, 17): 1, (4, 5): 1, (14, 15): 1, (2, 6): 1, (3, 19): 1, (11, 18): 1, (12, 13): 1, (9, 10): 1, (0, 1): 1, (7, 8): 1, (18, 19): 2, (5, 6): 2, (4, 17): 2, (0, 10): 2, (9, 13): 2, (1, 8): 2, (15, 16): 2, (11, 12): 2, (2, 3): 2, (7, 14): 2}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of colors =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Number of colors = 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.edge_k_coloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">edge_k_coloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#edge_k_coloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.edge_k_coloring" title="Link to this definition">¶</a></dt>
<dd><p>Attempts to color the edges of a graph <code class="docutils literal notranslate"><span class="pre">G</span></code> using <code class="docutils literal notranslate"><span class="pre">k</span></code> colors so that adjacent edges have different colors (a pair of edges is considered adjacent if and only if they share a common endpoint). A set of edges assigned to the same color corresponds to a matching; hence the equivalent aim is to partition the graph’s edges into <code class="docutils literal notranslate"><span class="pre">k</span></code> matchings.</p>
<p>The smallest number of colors needed for coloring the edges of a graph <span class="math notranslate nohighlight">\(G\)</span> is known as the graph’s chromatic index, denoted by <span class="math notranslate nohighlight">\(\chi'(G)\)</span>. Equivalently, <span class="math notranslate nohighlight">\(\chi'(G)\)</span> is the minimum number of matchings needed to partition the nodes of a simple graph <span class="math notranslate nohighlight">\(G\)</span>. According to Vizing’s theorem <a class="reference internal" href="#r73c0bd6c300a-1" id="id30">[1]</a>, <span class="math notranslate nohighlight">\(\chi'(G)\)</span> is either <span class="math notranslate nohighlight">\(\Delta(G)\)</span> or <span class="math notranslate nohighlight">\(\Delta(G) + 1\)</span>, where <span class="math notranslate nohighlight">\(\Delta(G)\)</span> is the maximum degree in <span class="math notranslate nohighlight">\(G\)</span>. The problem of determining an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring is polynomially solvable for any <span class="math notranslate nohighlight">\(k &gt; \Delta(G)\)</span>. Similarly, it is certain no edge <span class="math notranslate nohighlight">\(k\)</span>-coloring exists for <span class="math notranslate nohighlight">\(k &lt; \Delta(G)\)</span>. For <span class="math notranslate nohighlight">\(k = \Delta(G)\)</span>, however, the problem is NP-hard.</p>
<p>This method therefore includes options for using an exact exponential-time algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for larger values of <span class="math notranslate nohighlight">\(k\)</span>, for graphs that are small, or graphs that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</p>
<p>This method follows the steps used by the <a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_k_coloring()</span></code></a> method. That is, edge <span class="math notranslate nohighlight">\(k\)</span>-colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span> and then passing <span class="math notranslate nohighlight">\(L(G)\)</span> to the <a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_k_coloring()</span></code></a> method. All parameters are therefore the same as the latter. (Note that, if a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> has <span class="math notranslate nohighlight">\(n\)</span> nodes and <span class="math notranslate nohighlight">\(m\)</span> edges, its line graph <span class="math notranslate nohighlight">\(L(G)\)</span> will have <span class="math notranslate nohighlight">\(m\)</span> nodes and <span class="math notranslate nohighlight">\(\frac{1}{2}\sum_{v\in V}\deg(v)^2 - m\)</span> edges.)</p>
<p>If an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring cannot be determined by the algorithm, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> exception is raised. Otherwise, an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The edges of this graph will be colored.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The number of colors to use.</p>
</dd>
<dt><strong>opt_alg</strong><span class="classifier">None or int, optional (default=None)</span></dt><dd><p>An integer specifying the optimization method that will be used to try to reduce the number of colors (if this is seen to be greater than <span class="math notranslate nohighlight">\(k\)</span>). It must be one of the following</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when the existence of an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring has been proved or disproved.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes in <span class="math notranslate nohighlight">\(L(G)\)</span> to have the same color. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in <span class="math notranslate nohighlight">\(L(G)\)</span>, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges in <span class="math notranslate nohighlight">\(L(G)\)</span>, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors in the current solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes in <span class="math notranslate nohighlight">\(L(G)\)</span> to be uncolored. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, as above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> : No optimization is performed.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Only applicable when using <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots,k-1\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">opt_alg</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.
If <code class="docutils literal notranslate"><span class="pre">k</span></code> is not a nonnegative integer.
If a clique larger than <code class="docutils literal notranslate"><span class="pre">k</span></code> is observed in the line graph of <span class="math notranslate nohighlight">\(G\)</span>.
If <code class="docutils literal notranslate"><span class="pre">k</span></code> is less than the maximum degree in <code class="docutils literal notranslate"><span class="pre">G</span></code>.
If an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring could not be determined.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.edge_coloring" title="gcol.coloring.edge_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.equitable_edge_k_coloring" title="gcol.coloring.equitable_edge_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equitable_edge_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_k_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>As mentioned, in this implementation, edge colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span> and then passing <span class="math notranslate nohighlight">\(L(G)\)</span> to the <a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_k_coloring()</span></code></a> method. All details are therefore the same as those in the latter. The routine halts immediately once an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring has been achieved.</p>
<p>All the above algorithms and bounds are described in detail in <a class="reference internal" href="#r73c0bd6c300a-2" id="id31">[2]</a>. The c++ code used in <a class="reference internal" href="#r73c0bd6c300a-2" id="id32">[2]</a> and <a class="reference internal" href="#r73c0bd6c300a-3" id="id33">[3]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r73c0bd6c300a-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id30">1</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Vizing’s Theorem &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Vizing%27s_theorem">https://en.wikipedia.org/wiki/Vizing%27s_theorem</a>&gt;</p>
</div>
<div class="citation" id="r73c0bd6c300a-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id31">1</a>,<a role="doc-backlink" href="#id32">2</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="r73c0bd6c300a-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id33">3</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">edge_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">{(11, 12): 0, (11, 18): 1, (10, 11): 2, (12, 16): 3, (12, 13): 1, (18, 19): 0, (17, 18): 2, (16, 17): 0, (4, 17): 3, (15, 16): 1, (0, 10): 3, (9, 10): 0, (0, 19): 2, (9, 13): 2, (3, 19): 1, (0, 1): 0, (8, 9): 3, (13, 14): 3, (3, 4): 2, (1, 8): 1, (14, 15): 0, (4, 5): 1, (2, 3): 3, (1, 2): 2, (7, 8): 0, (5, 15): 2, (7, 14): 1, (2, 6): 0, (5, 6): 3, (6, 7): 2}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">edge_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">{(11, 12): 0, (11, 18): 1, (10, 11): 2, (12, 16): 1, (12, 13): 2, (18, 19): 0, (17, 18): 2, (16, 17): 0, (4, 17): 1, (15, 16): 2, (0, 10): 0, (9, 10): 1, (9, 13): 0, (8, 9): 2, (13, 14): 1, (14, 15): 0, (5, 15): 1, (7, 14): 2, (0, 19): 1, (3, 19): 2, (0, 1): 2, (3, 4): 0, (2, 3): 1, (1, 2): 0, (2, 6): 2, (5, 6): 0, (4, 5): 2, (1, 8): 1, (6, 7): 1, (7, 8): 0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.edge_precoloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">edge_precoloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dsatur'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#edge_precoloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.edge_precoloring" title="Link to this definition">¶</a></dt>
<dd><p>Returns a coloring of a graph’s edges in which some of the edges have been precolored.</p>
<p>An edge coloring of a graph is an assignment of colors to edges so that adjacent edges have different colors (a pair of edges is considered adjacent if and only if they share a common endpoint). The aim is to use as few colors as possible. A set of edges assigned to the same color corresponds to a matching; hence the equivalent aim is to partition the graph’s edges into a minimum number of matchings.</p>
<p>In the edge precoloring problem, some of the edges have already been assigned colors. The aim is to allocate colors to the remaining edges so that we get a full edge coloring that uses a minimum number of colors.</p>
<p>The edge precoloring problem is NP-hard. This method therefore includes options for using an exponential-time exact algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for graphs that are small, or that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</p>
<p>In this implementation, edge colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span> and then passing <span class="math notranslate nohighlight">\(L(G)\)</span> to the <a class="reference internal" href="#gcol.coloring.node_precoloring" title="gcol.coloring.node_precoloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_precoloring()</span></code></a> method. All parameters are therefore the same as the latter. (Note that, if a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> has <span class="math notranslate nohighlight">\(n\)</span> nodes and <span class="math notranslate nohighlight">\(m\)</span> edges, its line graph <span class="math notranslate nohighlight">\(L(G)\)</span> will have <span class="math notranslate nohighlight">\(m\)</span> nodes and <span class="math notranslate nohighlight">\(\frac{1}{2}\sum_{v\in V}\deg(v)^2 - m\)</span> edges.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The edges of this graph will be colored.</p>
</dd>
<dt><strong>precol</strong><span class="classifier">None or dict, optional (default=None)</span></dt><dd><p>A dictionary that specifies the colors of any precolored edges.</p>
</dd>
<dt><strong>strategy</strong><span class="classifier">string, optional (default=’dsatur’)</span></dt><dd><p>A string specifying the method used to generate the initial solution. It must be one of the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'random'</span></code> : Randomly orders <span class="math notranslate nohighlight">\(L(G)\)</span>’s nodes and then applies the greedy algorithm for graph node coloring <a class="reference internal" href="#rc38285201e32-1" id="id37">[1]</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'welsh-powell'</span></code> : Orders <span class="math notranslate nohighlight">\(L(G)\)</span>’s nodes by decreasing degree, then applies the greedy algorithm.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dsatur'</span></code> : Uses the DSatur algorithm for graph node coloring on <span class="math notranslate nohighlight">\(L(G)\)</span> <a class="reference internal" href="#rc38285201e32-2" id="id38">[2]</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'rlf'</span></code> : Uses the recursive largest first (RLF) algorithm for graph node coloring on <span class="math notranslate nohighlight">\(L(G)\)</span> <a class="reference internal" href="#rc38285201e32-3" id="id39">[3]</a>.</p></li>
</ul>
</dd>
<dt><strong>opt_alg</strong><span class="classifier">None or int, optional (default=None)</span></dt><dd><p>An integer specifying the optimization method that will be used to try to reduce the number of colors. It must be one of the following</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when an optimal solution has been found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes in <span class="math notranslate nohighlight">\(L(G)\)</span> to have the same color. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in <span class="math notranslate nohighlight">\(L(G)\)</span>, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors in the current solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes in <span class="math notranslate nohighlight">\(L(G)\)</span> to be uncolored. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, as above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> : No optimization is performed.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Only applicable when using <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>. The number of colors being used in a solution <code class="docutils literal notranslate"><span class="pre">c</span></code> is therefore <code class="docutils literal notranslate"><span class="pre">max(c.values())</span> <span class="pre">+</span> <span class="pre">1</span></code>. If <code class="docutils literal notranslate"><span class="pre">precol[(u,v)]==j</span></code> then <code class="docutils literal notranslate"><span class="pre">c[(u,v)]==j</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strategy</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">opt_alg</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.
If <code class="docutils literal notranslate"><span class="pre">precol</span></code> contains an edge that is not in <code class="docutils literal notranslate"><span class="pre">G</span></code>.
If <code class="docutils literal notranslate"><span class="pre">precol</span></code> contains a non-integer color label.
If <code class="docutils literal notranslate"><span class="pre">precol</span></code> contains a pair of adjacent edges assigned to the same color.
If <code class="docutils literal notranslate"><span class="pre">precol</span></code> uses an integer color label <span class="math notranslate nohighlight">\(j\)</span>, but there exists a color label <span class="math notranslate nohighlight">\(0 \leq i &lt; j\)</span> that is not being used.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.edge_coloring" title="gcol.coloring.edge_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.node_precoloring" title="gcol.coloring.node_precoloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_precoloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>As mentioned, in this implementation, edge colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span> and then passing <span class="math notranslate nohighlight">\(L(G)\)</span> to the <a class="reference internal" href="#gcol.coloring.node_precoloring" title="gcol.coloring.node_precoloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_precoloring()</span></code></a> method. All details are therefore the same as those in the latter, where they are documented.</p>
<p>All the above algorithms and bounds are described in detail in <a class="reference internal" href="#rc38285201e32-4" id="id40">[4]</a>. The c++ code used in <a class="reference internal" href="#rc38285201e32-4" id="id41">[4]</a> and <a class="reference internal" href="#rc38285201e32-5" id="id42">[5]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rc38285201e32-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id37">1</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Greedy Coloring &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Greedy_coloring">https://en.wikipedia.org/wiki/Greedy_coloring</a>&gt;</p>
</div>
<div class="citation" id="rc38285201e32-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id38">2</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: DSatur &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/DSatur">https://en.wikipedia.org/wiki/DSatur</a>&gt;</p>
</div>
<div class="citation" id="rc38285201e32-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id39">3</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Recursive largest first (RLF) algorithm &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm">https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm</a>&gt;</p>
</div>
<div class="citation" id="rc38285201e32-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id40">1</a>,<a role="doc-backlink" href="#id41">2</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="rc38285201e32-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id42">5</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">edge_precoloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">precol</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coloring is&quot;</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="go">Coloring is {(0, 1): 0, (8, 9): 1, (10, 11): 2, (11, 12): 3, (1, 8): 2, (0, 10): 1, (9, 10): 0, (11, 18): 0, (7, 8): 0, (1, 2): 1, (0, 19): 2, (9, 13): 2, (18, 19): 1, (12, 13): 0, (17, 18): 2, (3, 19): 0, (12, 16): 1, (13, 14): 1, (2, 3): 2, (16, 17): 0, (7, 14): 2, (3, 4): 1, (4, 17): 3, (2, 6): 0, (15, 16): 2, (14, 15): 0, (6, 7): 1, (4, 5): 0, (5, 15): 1, (5, 6): 2}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of colors =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Number of colors = 4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.equitable_edge_k_coloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">equitable_edge_k_coloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#equitable_edge_k_coloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.equitable_edge_k_coloring" title="Link to this definition">¶</a></dt>
<dd><p>Attempts to color the edges of a graph using <code class="docutils literal notranslate"><span class="pre">k</span></code> colors so that (a) adjacent edges have different colors, and (b) the weight of each color class is equal. (A pair of edges is considered adjacent if and only if they share a common endpoint.) If <code class="docutils literal notranslate"><span class="pre">weight=None</span></code>, the weight of a color class is the number of edges assigned to that color; otherwise, it is the sum of the weights of the edges assigned to that color.</p>
<p>Equivalently, this routine seeks to partition the graph’s edges into <span class="math notranslate nohighlight">\(k\)</span> matchings so that the weight of each matching is equal.</p>
<p>This method first follows the steps used by the <a class="reference internal" href="#gcol.coloring.edge_k_coloring" title="gcol.coloring.edge_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">edge_k_coloring()</span></code></a> method to try and find an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring. That is, edge colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span> and then passing <span class="math notranslate nohighlight">\(L(G)\)</span> to the <a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_k_coloring()</span></code></a> method. All parameters are therefore the same as the latter. (Note that, if a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> has <span class="math notranslate nohighlight">\(n\)</span> nodes and <span class="math notranslate nohighlight">\(m\)</span> edges, its line graph <span class="math notranslate nohighlight">\(L(G)\)</span> will have <span class="math notranslate nohighlight">\(m\)</span> nodes and <span class="math notranslate nohighlight">\(\frac{1}{2}\sum_{v\in V}\deg(v)^2 - m\)</span> edges.)</p>
<p>If an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring cannot be determined by the algorithm, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> exception is raised. Otherwise, once an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring has been formed, the algorithm uses a bespoke local search operator to reduce the variance in weights across the <span class="math notranslate nohighlight">\(k\)</span> colors. In solutions returned by this method, adjacent edges always receive different colors; however, the coloring is not guaranteed to be equitable, even if an equitable edge <span class="math notranslate nohighlight">\(k\)</span>-coloring exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The edges of this graph will be colored.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The number of colors to use.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">None or string, optional (default=None)</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, every edge is assumed to have a weight of <code class="docutils literal notranslate"><span class="pre">1</span></code>. If a string, this should correspond to a defined edge attribute. Edge weights must be positive.</p>
</dd>
<dt><strong>opt_alg</strong><span class="classifier">None or int, optional (default=None)</span></dt><dd><p>An integer specifying the optimization method that will be used to try to reduce the number of colors (if this is seen to be greater than <code class="docutils literal notranslate"><span class="pre">k</span></code>). It must be one of the following</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when the existence of an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring has been proved or disproved.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes in <span class="math notranslate nohighlight">\(L(G)\)</span> to have the same color. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in <span class="math notranslate nohighlight">\(L(G)\)</span>, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges in <span class="math notranslate nohighlight">\(L(G)\)</span>, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors in the current solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes in <span class="math notranslate nohighlight">\(L(G)\)</span> to be uncolored. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, as above.</p></li>
<li><p>None : No optimization is performed.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Only applicable when using <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots,k-1\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">opt_alg</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.
If <code class="docutils literal notranslate"><span class="pre">k</span></code> is not a nonnegative integer.
If a clique larger than <code class="docutils literal notranslate"><span class="pre">k</span></code> is observed in the line graph of <span class="math notranslate nohighlight">\(G\)</span>.
If <code class="docutils literal notranslate"><span class="pre">k</span></code> is less than the maximum degree in <code class="docutils literal notranslate"><span class="pre">G</span></code>.
If an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring could not be determined.
If an edge with a non-positive weight is specified.</p>
</dd>
<dt>KeyError</dt><dd><p>If an edge does not have the attribute defined by <code class="docutils literal notranslate"><span class="pre">weight</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.edge_k_coloring" title="gcol.coloring.edge_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.equitable_node_k_coloring" title="gcol.coloring.equitable_node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equitable_node_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.kempe_chain" title="gcol.coloring.kempe_chain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kempe_chain</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>As mentioned, in this implementation edge colorings of a graph <span class="math notranslate nohighlight">\(G\)</span> are determined by forming <span class="math notranslate nohighlight">\(G\)</span>’s line graph <span class="math notranslate nohighlight">\(L(G)\)</span> and then following the same steps as the <a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_k_coloring()</span></code></a> method to try and find a node <span class="math notranslate nohighlight">\(k\)</span>-coloring of <span class="math notranslate nohighlight">\(L(G)\)</span>; however, it also takes edge weights into account if needed. If an edge <span class="math notranslate nohighlight">\(k\)</span>-coloring is achieved, a bespoke local search operator (based on steepest descent) is then used to try to reduce the variance in weights across the <span class="math notranslate nohighlight">\(k\)</span> color classes. This follows the same steps as the <a class="reference internal" href="#gcol.coloring.equitable_node_k_coloring" title="gcol.coloring.equitable_node_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">equitable_node_k_coloring()</span></code></a> method, using <span class="math notranslate nohighlight">\(L(G)\)</span>. Further details on this optimization method can be found in Chapter 7 of <a class="reference internal" href="#r1344bdc4c704-2" id="id48">[2]</a>, or in <a class="reference internal" href="#r1344bdc4c704-3" id="id49">[3]</a>.</p>
<p>All the above algorithms are described in detail in <a class="reference internal" href="#r1344bdc4c704-2" id="id50">[2]</a>. The c++ code used in <a class="reference internal" href="#r1344bdc4c704-2" id="id51">[2]</a> and <a class="reference internal" href="#r1344bdc4c704-4" id="id52">[4]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r1344bdc4c704-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Wikipedia: Vizing’s Theorem &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Vizing%27s_theorem">https://en.wikipedia.org/wiki/Vizing%27s_theorem</a>&gt;</p>
</div>
<div class="citation" id="r1344bdc4c704-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id48">1</a>,<a role="doc-backlink" href="#id50">2</a>,<a role="doc-backlink" href="#id51">3</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="r1344bdc4c704-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id49">3</a><span class="fn-bracket">]</span></span>
<p>Lewis, R. and F. Carroll (2016) ‘Creating Seating Plans: A Practical Application’. Journal of the Operational Research Society, vol. 67(11), pp. 1353-1362.</p>
</div>
<div class="citation" id="r1344bdc4c704-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id52">4</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">equitable_edge_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[[(11, 12), (18, 19), (16, 17), (9, 10), (0, 1), (14, 15), (7, 8), (2, 6)], [(11, 18), (12, 13), (15, 16), (3, 19), (1, 8), (4, 5), (7, 14)], [(10, 11), (17, 18), (0, 19), (9, 13), (3, 4), (1, 2), (5, 15), (6, 7)], [(12, 16), (4, 17), (0, 10), (8, 9), (13, 14), (2, 3), (5, 6)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of smallest color class =&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">P</span><span class="p">))</span>
<span class="go">Size of smallest color class = 7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of biggest color class =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">P</span><span class="p">))</span>
<span class="go">Size of biggest color class = 8</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#Now add some (arbitrary) weights to the edges</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">equitable_edge_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[[(11, 12), (18, 19), (4, 17), (13, 14), (1, 8), (2, 3)], [(11, 18), (9, 13), (0, 1), (3, 4), (5, 15), (7, 8)], [(10, 11), (17, 18), (15, 16), (0, 19), (1, 2), (6, 7)], [(12, 16), (9, 10), (3, 19), (14, 15), (5, 6)], [(12, 13), (16, 17), (0, 10), (8, 9), (4, 5), (7, 14), (2, 6)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weight of lightest color class =&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">P</span><span class="p">))</span>
<span class="go">Weight of lightest color class = 23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weight of heaviest color class =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">P</span><span class="p">))</span>
<span class="go">Weight of heaviest color class = 25</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.equitable_node_k_coloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">equitable_node_k_coloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#equitable_node_k_coloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.equitable_node_k_coloring" title="Link to this definition">¶</a></dt>
<dd><p>Attempts to color the nodes of a graph using <code class="docutils literal notranslate"><span class="pre">k</span></code> colors so that (a) all adjacent nodes have different colors, and (b) the weight of each color class is equal. If <code class="docutils literal notranslate"><span class="pre">weight=None</span></code>, the weight of a color class is the number of nodes assigned to that color; otherwise, it is the sum of the weights of the nodes assigned to that color.</p>
<p>Equivalently, this routine seeks to partition the graph’s nodes into <code class="docutils literal notranslate"><span class="pre">k</span></code> independent sets so that the weight of each independent set is equal.</p>
<p>Determining an equitable node <span class="math notranslate nohighlight">\(k\)</span>-coloring is NP-hard. This method first follows the steps used by the <a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_k_coloring()</span></code></a> method to try and find a node <span class="math notranslate nohighlight">\(k\)</span>-coloring. If this is achieved, the algorithm then uses a bespoke local search operator to reduce the variance in weights across the <span class="math notranslate nohighlight">\(k\)</span> colors.</p>
<p>If a node <span class="math notranslate nohighlight">\(k\)</span>-coloring cannot be determined by the algorithm, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> exception is raised. Otherwise, a node <span class="math notranslate nohighlight">\(k\)</span>-coloring is returned in which the variance in weights across the <span class="math notranslate nohighlight">\(k\)</span> color classes has been minimized. In solutions returned by this method, neighboring nodes always receive different colors; however, the coloring is not guaranteed to be equitable, even if an equitable node <span class="math notranslate nohighlight">\(k\)</span>-coloring exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The nodes of this graph will be colored.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The number of colors to use.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">None or string, optional (default=None)</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, every node is assumed to have a weight of <code class="docutils literal notranslate"><span class="pre">1</span></code>. If string, this should correspond to a defined node attribute. Node weights must be positive.</p>
</dd>
<dt><strong>opt_alg</strong><span class="classifier">int, optional (default=None)</span></dt><dd><p>An integer specifying the optimization method that will be used to try to reduce the number of colors (if this is seen to be greater than <span class="math notranslate nohighlight">\(k\)</span>). It must be one of the following</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when the existence of a node <span class="math notranslate nohighlight">\(k\)</span>-coloring has been proved or disproved.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes to have the same color. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in the modified graph, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors in the current solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes to be uncolored. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, as above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> : No optimization is performed.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Only applicable when using <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots,k-1\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">opt_alg</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.
If <code class="docutils literal notranslate"><span class="pre">k</span></code> is not a nonnegative integer.
If a clique larger than <code class="docutils literal notranslate"><span class="pre">k</span></code> is observed in the graph.
If a node <span class="math notranslate nohighlight">\(k\)</span>-coloring could not be determined.
If a node with a non-positive weight is specified.</p>
</dd>
<dt>KeyError</dt><dd><p>If a node does not have the attribute defined by <code class="docutils literal notranslate"><span class="pre">weight</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.equitable_edge_k_coloring" title="gcol.coloring.equitable_edge_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equitable_edge_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.kempe_chain" title="gcol.coloring.kempe_chain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kempe_chain</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This method first follows the same steps as the <a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_k_coloring()</span></code></a> method to try and find a node <span class="math notranslate nohighlight">\(k\)</span>-coloring; however, it also takes node weights into account if needed. If a node <span class="math notranslate nohighlight">\(k\)</span>-coloring is achieved, a bespoke local search operator (based on steepest descent) is then used to try to reduce the variance in weights across the <span class="math notranslate nohighlight">\(k\)</span> color classes. This process involves evaluating each Kempe-chain interchange in the current solution <a class="reference internal" href="#r9daad0f03637-1" id="id57">[1]</a> and performing the interchange that results in the largest reduction in variance. This process repeats until there are no interchanges that reduce the variance. Each iteration of this local search process takes <span class="math notranslate nohighlight">\(O(n^2)\)</span> time. Further details on this optimization method can be found in Chapter 7 of [2], or in <a class="reference internal" href="#r9daad0f03637-3" id="id58">[3]</a>.</p>
<p>All the above algorithms are described in detail in <a class="reference internal" href="#r9daad0f03637-2" id="id59">[2]</a>. The c++ code used in <a class="reference internal" href="#r9daad0f03637-2" id="id60">[2]</a> and <a class="reference internal" href="#r9daad0f03637-4" id="id61">[4]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r9daad0f03637-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id57">1</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Kempe Chain &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Kempe_chain">https://en.wikipedia.org/wiki/Kempe_chain</a>&gt;</p>
</div>
<div class="citation" id="r9daad0f03637-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id59">1</a>,<a role="doc-backlink" href="#id60">2</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="r9daad0f03637-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id58">3</a><span class="fn-bracket">]</span></span>
<p>Lewis, R. and F. Carroll (2016) ‘Creating Seating Plans: A Practical Application’. Journal of the Operational Research Society, vol. 67(11), pp. 1353-1362.</p>
</div>
<div class="citation" id="r9daad0f03637-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id61">4</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">equitable_node_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[[0, 2, 9, 5, 14], [1, 3, 11, 7, 17], [19, 8, 6, 13, 16], [10, 18, 4, 12, 15]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of smallest color class =&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">P</span><span class="p">))</span>
<span class="go">Size of smallest color class = 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of biggest color class =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">P</span><span class="p">))</span>
<span class="go">Size of biggest color class = 5</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#Now do similar with a node-weighted graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">equitable_node_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[[2], [0], [1, 3]]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weight of lightest color class =&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">P</span><span class="p">))</span>
<span class="go">Weight of lightest color class = 19</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weight of heaviest color class =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">P</span><span class="p">))</span>
<span class="go">Weight of heaviest color class = 25</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.get_edge_colors">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">get_edge_colors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#get_edge_colors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.get_edge_colors" title="Link to this definition">¶</a></dt>
<dd><p>Generates an RGB color for each edge in the graph <code class="docutils literal notranslate"><span class="pre">G</span></code> based on its color label in <code class="docutils literal notranslate"><span class="pre">c</span></code>. This method is designed to be used with the <code class="docutils literal notranslate"><span class="pre">edge_color</span></code> argument in the drawing functions of NetworkX (see example below). If an edge is marked as uncolored (i.e., assigned a negative value, or not present in <code class="docutils literal notranslate"><span class="pre">c</span></code>), it is painted light grey.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The graph we want to visualize.</p>
</dd>
<dt><strong>c</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>A list specifying the RGB color that each edge should be painted with.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">c</span></code> uses more than 56 colors.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.get_set_colors" title="gcol.coloring.get_set_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_set_colors</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.get_node_colors" title="gcol.coloring.get_node_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_node_colors</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Color 0 is set to red; color 1, green; and color, 2 blue. Beyond this, a sequence of RGB values are generated for each integer, aiming to keep the presented colors as distict as possible.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">edge_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">gcol</span><span class="o">.</span><span class="n">get_edge_colors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.get_node_colors">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">get_node_colors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#get_node_colors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.get_node_colors" title="Link to this definition">¶</a></dt>
<dd><p>Generates an RGB color for each node in the graph <code class="docutils literal notranslate"><span class="pre">G</span></code> based on its color label in <code class="docutils literal notranslate"><span class="pre">c</span></code>. This method is designed to be used with the <code class="docutils literal notranslate"><span class="pre">node_color</span></code> argument in the drawing functions of NetworkX (see example below). If a node is marked as uncolored (i.e., assigned a negative value, or not present in <code class="docutils literal notranslate"><span class="pre">c</span></code>), it is painted white.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The graph we want to visualize.</p>
</dd>
<dt><strong>c</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>A list specifying the RGB color that each node should be painted with.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">c</span></code> uses more than 56 colors.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.get_set_colors" title="gcol.coloring.get_set_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_set_colors</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.get_edge_colors" title="gcol.coloring.get_edge_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_colors</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Color 0 is set to red; color 1, green; and color, 2 blue. Beyond this, a sequence of RGB values are generated for each integer, aiming to keep the presented colors as distict as possible.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">node_color</span><span class="o">=</span><span class="n">gcol</span><span class="o">.</span><span class="n">get_node_colors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.get_set_colors">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">get_set_colors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'yellow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'grey'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#get_set_colors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.get_set_colors" title="Link to this definition">¶</a></dt>
<dd><p>Generates an RGB color for each node in the graph based on whether it is a member of the set <code class="docutils literal notranslate"><span class="pre">S</span></code>. By default, nodes in <code class="docutils literal notranslate"><span class="pre">S</span></code> are painted yellow and all others are painted grey. This method is designed to be used with the <code class="docutils literal notranslate"><span class="pre">node_color</span></code> argument in the drawing functions of NetworkX (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The graph we want to visualize.</p>
</dd>
<dt><strong>S</strong><span class="classifier">list or set</span></dt><dd><p>A subset of <code class="docutils literal notranslate"><span class="pre">G</span></code>’s nodes.</p>
</dd>
<dt><strong>S_color</strong><span class="classifier">color, optional (default=’yellow’)</span></dt><dd><p>Desired color of the nodes in <code class="docutils literal notranslate"><span class="pre">S</span></code>. Other options include <code class="docutils literal notranslate"><span class="pre">'blue'</span></code>, <code class="docutils literal notranslate"><span class="pre">'cyan'</span></code>, <code class="docutils literal notranslate"><span class="pre">'green'</span></code>, <code class="docutils literal notranslate"><span class="pre">'black'</span></code>, <code class="docutils literal notranslate"><span class="pre">'magenta'</span></code>, <code class="docutils literal notranslate"><span class="pre">'red'</span></code>, <code class="docutils literal notranslate"><span class="pre">'white'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'yellow'</span></code>.</p>
</dd>
<dt><strong>other_color</strong><span class="classifier">color, optional (default=’grey’)</span></dt><dd><p>Desired color of the nodes not in <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>A list specifying the RGB color that each node should be painted with.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.get_node_colors" title="gcol.coloring.get_node_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_node_colors</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.get_edge_colors" title="gcol.coloring.get_edge_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_colors</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">max_independent_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">),</span> <span class="n">node_color</span><span class="o">=</span><span class="n">gcol</span><span class="o">.</span><span class="n">get_set_colors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.kempe_chain">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">kempe_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#kempe_chain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.kempe_chain" title="Link to this definition">¶</a></dt>
<dd><p>Given a node coloring <code class="docutils literal notranslate"><span class="pre">c</span></code> of a graph <code class="docutils literal notranslate"><span class="pre">G</span></code>, this method returns the set of nodes in the Kempe chain generated from a source node <code class="docutils literal notranslate"><span class="pre">s</span></code> using the color <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p>
<p>A Kempe chain is a connected set of nodes in a graph that alternates between two colors <a class="reference internal" href="#r43a25fbf8150-1" id="id66">[1]</a>. Equivalently, it is a maximal connected subgraph that contains nodes of at most two colors. Interchanging the colors of the nodes in a Kempe chain creates a new coloring that uses the same number of colors or one fewer color. Two <span class="math notranslate nohighlight">\(k\)</span>-colorings of a graph are considered <em>Kempe equivalent</em> if one can be obtained from the other through a series of Kempe chain interchanges <a class="reference internal" href="#r43a25fbf8150-2" id="id67">[2]</a>. It is also known that, if <span class="math notranslate nohighlight">\(k\)</span> is larger than the degeneracy of a graph, then all <span class="math notranslate nohighlight">\(k\)</span>-colorings of this graph are Kempe equivalent <a class="reference internal" href="#r43a25fbf8150-2" id="id68">[2]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The graph that we want to compute a Kempe chain for.</p>
</dd>
<dt><strong>c</strong><span class="classifier">dict</span></dt><dd><p>A node coloring of <code class="docutils literal notranslate"><span class="pre">G</span></code>. Pairs of adjacent nodes cannot be allocated to the same color. Any uncolored nodes <code class="docutils literal notranslate"><span class="pre">u</span></code> should have <code class="docutils literal notranslate"><span class="pre">c[u]==-1</span></code>.</p>
</dd>
<dt><strong>s</strong><span class="classifier">node</span></dt><dd><p>The source node that we will generate the Kempe chain from.</p>
</dd>
<dt><strong>j</strong><span class="classifier">int</span></dt><dd><p>The second color to use. The first color is that of <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>set</dt><dd><p>The set of nodes, reachable from <code class="docutils literal notranslate"><span class="pre">s</span></code>, that alternate between colors <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> (where <code class="docutils literal notranslate"><span class="pre">c[s]==i</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">c</span></code> contains a pair of adjacent nodes assigned to the same color.
If <code class="docutils literal notranslate"><span class="pre">c</span></code> contains an invalid color label or no color label for <code class="docutils literal notranslate"><span class="pre">s</span></code>.
If <code class="docutils literal notranslate"><span class="pre">G</span></code> contains a node that is not in <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.equitable_node_k_coloring" title="gcol.coloring.equitable_node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equitable_node_k_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This method uses an extension of breadth-first search and operates in <span class="math notranslate nohighlight">\(O(n+m)\)</span> time. If <code class="docutils literal notranslate"><span class="pre">c[s]==j</span></code>, then the Kempe chain contains node <code class="docutils literal notranslate"><span class="pre">s</span></code> only.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r43a25fbf8150-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id66">1</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Kempe Chain &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Kempe_chain">https://en.wikipedia.org/wiki/Kempe_chain</a>&gt;</p>
</div>
<div class="citation" id="r43a25fbf8150-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id67">1</a>,<a role="doc-backlink" href="#id68">2</a>)</span>
<p>Cranston, D. (2024) Graph Coloring Methods &lt;<a class="reference external" href="https://graphcoloringmethods.com/">https://graphcoloringmethods.com/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">kempe_chain</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example Kempe chain =&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="go">Example Kempe chain = {0, 1, 2, 4, 6, 8, 10, 17, 18, 19}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.max_independent_set">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">max_independent_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#max_independent_set"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.max_independent_set" title="Link to this definition">¶</a></dt>
<dd><p>Attempts to identify the largest independent set of nodes in a graph. Nodes can also be allocated weights if desired.</p>
<p>The maximum independent set in a graph <span class="math notranslate nohighlight">\(G\)</span> is the largest subset of nodes in which none are adjacent. The size of the largest independent in a graph <span class="math notranslate nohighlight">\(G\)</span> is known as the independence number of <span class="math notranslate nohighlight">\(G\)</span> and is often denoted by <span class="math notranslate nohighlight">\(\alpha(G)\)</span>. Similarly, the maximum-weighted independent set in <span class="math notranslate nohighlight">\(G\)</span> is the subset of mutually nonadjacent nodes whose weight-total is maximized.</p>
<p>The problem of determining a maximum(-weighted) independent set of nodes is NP-hard. Consequently, this method makes use of a polynomial-time heuristic based on local search. It will always return an independent set but offers no guarantees on whether this is the optimal solution. The algorithm halts once the iteration limit has been reached.</p>
<p>Note that the similar problem of determining the maximum(-weighted) independent set of edges is equivalent to finding a maximum(-weighted) matching in a graph. This is a polynomially solvable problem and can be solved by the Blossom algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>An independent set of nodes in this graph will be returned.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">None or string, optional (default=None)</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, every node is assumed to have a weight of <code class="docutils literal notranslate"><span class="pre">1</span></code>. If a string, this should correspond to a defined node attribute. All node weights must be positive.</p>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes and <span class="math notranslate nohighlight">\(m\)</span> is the number of edges.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>A list containing the nodes belonging to the independent set.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.
If a node with a non-positive weight is specified.</p>
</dd>
<dt>KeyError</dt><dd><p>If a node does not have the attribute defined by <code class="docutils literal notranslate"><span class="pre">weight</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This method uses the PartialCol algorithm for node <span class="math notranslate nohighlight">\(k\)</span>-coloring using <span class="math notranslate nohighlight">\(k=1\)</span>. The set of nodes assigned to this color corresponds to the independent set. PartialCol is based on tabu search. Here, each iteration of PartialCol has complexity <span class="math notranslate nohighlight">\(O(n + m)\)</span>. It also occupies <span class="math notranslate nohighlight">\(O(n + m)\)</span> of memory space.</p>
<p>The above algorithm is described in detail in <a class="reference internal" href="#r81a3221b0047-1" id="id71">[1]</a>. The c++ code used in <a class="reference internal" href="#r81a3221b0047-1" id="id72">[1]</a> and <a class="reference internal" href="#r81a3221b0047-2" id="id73">[2]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r81a3221b0047-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id71">1</a>,<a role="doc-backlink" href="#id72">2</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="r81a3221b0047-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id73">2</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">max_independent_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Independent set =&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="go">Independent set = [19, 10, 2, 8, 5, 12, 14, 17]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Do similar with a node-weighted graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">max_independent_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Independent set =&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="go">Independent set = [0, 1, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.min_cost_k_coloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">min_cost_k_coloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights_at</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nodes'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#min_cost_k_coloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.min_cost_k_coloring" title="Link to this definition">¶</a></dt>
<dd><p>Colors the nodes of the graph using <code class="docutils literal notranslate"><span class="pre">k</span></code> colors so that a cost function is minimized. Equivalently, this routine partitions a graph’s nodes while attempting to minimize a specific cost function.</p>
<p>This routine will always produce a <span class="math notranslate nohighlight">\(k\)</span>-coloring. However, this solution may include some clashes (that is, instances of adjacent nodes having the same color), or uncolored nodes. The aim is to minimize the number (or total weight) of these occurrences.</p>
<p>Determining a minimum cost solution to these problems is NP-hard. This routine employs polynomial-time heuristic algorithms based on local search.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The nodes of this graph will be colored.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The number of colors to use.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">None or string, optional (default=None)</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, every node and edge is assumed to have a weight of <code class="docutils literal notranslate"><span class="pre">1</span></code>. If string, this should correspond to a defined node or edge attribute. All node and edge weights must be positive.</p>
</dd>
<dt><strong>weights_at</strong><span class="classifier">string, optional (default=’nodes’)</span></dt><dd><p>A string that must be one of the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'nodes'</span></code> : Here, nodes can be left uncolored in a solution. If <code class="docutils literal notranslate"><span class="pre">weight=None</span></code>, the method seeks a <span class="math notranslate nohighlight">\(k\)</span>-coloring in which the number of uncolored nodes is minimized; otherwise, the method seeks a <span class="math notranslate nohighlight">\(k\)</span>-coloring that minimizes the sum of the weights of the uncolored nodes. Clashes are not permitted in a solution. The algorithm halts when a zero-cost solution has been determined (this corresponds to a full, proper node <span class="math notranslate nohighlight">\(k\)</span>-coloring), or when the iteration limit is reached.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'edges'</span></code> : Here, clashes are permitted in a solution. If <code class="docutils literal notranslate"><span class="pre">weight=None</span></code>, the method seeks a <span class="math notranslate nohighlight">\(k\)</span>-coloring in which the number of clashes is minimized; otherwise, the method seeks a coloring that minimizes the sum of the weights of edges involved in a clash. Uncolored nodes are not permitted in a solution. The algorithm halts when a zero-cost solution has been determined (this corresponds to a full, proper node <span class="math notranslate nohighlight">\(k\)</span>-coloring), or when the iteration limit is reached.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots,k-1\)</span>. Uncolored nodes are given a value of <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">weights_at</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.
If <code class="docutils literal notranslate"><span class="pre">k</span></code> is not a nonnegative integer.
If a node/edge with a non-positive weight is specified.</p>
</dd>
<dt>KeyError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">weights_at=='nodes'</span></code> and a node does not have the attribute defined by <code class="docutils literal notranslate"><span class="pre">weight</span></code>.
If <code class="docutils literal notranslate"><span class="pre">weights_at=='edges'</span></code> and an edge does not have the attribute defined by <code class="docutils literal notranslate"><span class="pre">weight</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_k_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">weights_at='edges'</span></code>, the TabuCol algorithm is used. This algorithm is based on tabu search and operates using <span class="math notranslate nohighlight">\(k\)</span> colors, allowing clashes to occur. The aim is to alter the color assignments so that the number of clashes (or the total weight of all clashing edges) is minimized. Each iteration of TabuCol has complexity <span class="math notranslate nohighlight">\(O(nk + m)\)</span>. The process also uses <span class="math notranslate nohighlight">\(O(nk + m)\)</span> memory.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">weights_at='nodes'</span></code>, the PartialCol algorithm is used. This algorithm is also based on tabu search and operates using <span class="math notranslate nohighlight">\(k\)</span> colors, allowing some nodes to be left uncolored. The aim is to make alterations to the color assignments so that the number of uncolored nodes (or the total weight of the uncolored nodes) is minimized. As with TabuCol, each iteration of PartialCol has complexity <span class="math notranslate nohighlight">\(O(nk +m)\)</span>. This process also uses <span class="math notranslate nohighlight">\(O(nk + m)\)</span> memory.</p>
<p>All the above algorithms are described in detail in <a class="reference internal" href="#r7da525eeac92-1" id="id76">[1]</a>. The c++ code used in <a class="reference internal" href="#r7da525eeac92-1" id="id77">[1]</a> and <a class="reference internal" href="#r7da525eeac92-2" id="id78">[2]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r7da525eeac92-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id76">1</a>,<a role="doc-backlink" href="#id77">2</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="r7da525eeac92-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id78">2</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Unweighted graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">min_cost_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weights_at</span><span class="o">=</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[[0, 2, 8, 18, 4, 13, 15], [1, 19, 10, 6, 12, 14, 17]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s2">&quot;is not colored&quot;</span><span class="p">)</span>
<span class="go">Node 3 is not colored</span>
<span class="go">Node 5 is not colored</span>
<span class="go">Node 7 is not colored</span>
<span class="go">Node 9 is not colored</span>
<span class="go">Node 11 is not colored</span>
<span class="go">Node 16 is not colored</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Edge-weighted graph (arbitrary weights)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">min_cost_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weights_at</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[[0, 2, 8, 18, 11, 7, 4, 13, 15, 16], [1, 19, 10, 3, 9, 6, 5, 12, 14, 17]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edge&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="s2">&quot;( cost =&quot;</span><span class="p">,</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">],</span> <span class="s2">&quot;) is clashing &quot;</span><span class="p">)</span>
<span class="go">Edge 3 19 ( cost = 16 ) is clashing</span>
<span class="go">Edge 5 6 ( cost = 1 ) is clashing</span>
<span class="go">Edge 7 8 ( cost = 1 ) is clashing</span>
<span class="go">Edge 9 10 ( cost = 1 ) is clashing</span>
<span class="go">Edge 11 18 ( cost = 7 ) is clashing</span>
<span class="go">Edge 15 16 ( cost = 1 ) is clashing</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.multipartite_layout">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">multipartite_layout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#multipartite_layout"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.multipartite_layout" title="Link to this definition">¶</a></dt>
<dd><p>Arranges the nodes of the graph into columns so that those of the same color are in the same column. This method is designed to be used with the <code class="docutils literal notranslate"><span class="pre">pos</span></code> argument in the drawing functions of NetworkX (see example below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The graph we want to visualize.</p>
</dd>
<dt><strong>c</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>. Nodes with negative color labels are ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pos</strong><span class="classifier">dict</span></dt><dd><p>A dictionary of positions keyed by node.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.get_node_colors" title="gcol.coloring.get_node_colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_node_colors</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.coloring_layout" title="gcol.coloring.coloring_layout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coloring_layout</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">gcol</span><span class="o">.</span><span class="n">multipartite_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">node_color</span><span class="o">=</span><span class="n">gcol</span><span class="o">.</span><span class="n">get_node_colors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.node_coloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">node_coloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dsatur'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#node_coloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.node_coloring" title="Link to this definition">¶</a></dt>
<dd><p>Returns a coloring of a graph’s nodes.</p>
<p>A node coloring of a graph is an assignment of colors to nodes so that adjacent nodes have different colors. The aim is to use as few colors as possible. A set of nodes assigned to the same color represents an independent set; hence the equivalent aim is to partition the graph’s nodes into a minimum number of independent sets.</p>
<p>The smallest number of colors needed to color the nodes of a graph <span class="math notranslate nohighlight">\(G\)</span> is known as the graph’s chromatic number, denoted by <span class="math notranslate nohighlight">\(\chi(G)\)</span>. Equivalently, <span class="math notranslate nohighlight">\(\chi(G)\)</span> is the minimum number of independent sets needed to partition the nodes of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Determining a node coloring that minimizes the number of colors is an NP-hard problem. This method therefore includes options for using an exact exponential-time algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for graphs that are small, or that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The nodes of this graph will be colored.</p>
</dd>
<dt><strong>strategy</strong><span class="classifier">string, optional (default=’dsatur’)</span></dt><dd><p>A string specifying the method used to generate an initial solution. It must be one of the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'random'</span></code> : Randomly orders the graph’s nodes and then applies the greedy algorithm for graph node coloring <a class="reference internal" href="#rb30d7dff8300-1" id="id81">[1]</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'welsh-powell'</span></code> : Orders the graph’s nodes by decreasing degree, then applies the greedy algorithm.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dsatur'</span></code> : Uses the DSatur algorithm for graph node coloring <a class="reference internal" href="#rb30d7dff8300-2" id="id82">[2]</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'rlf'</span></code> : Uses the recursive largest first (RLF) algorithm for graph node coloring <a class="reference internal" href="#rb30d7dff8300-3" id="id83">[3]</a>.</p></li>
</ul>
</dd>
<dt><strong>opt_alg</strong><span class="classifier">None or int, optional (default=None)</span></dt><dd><p>An integer specifying the optimization method that will be used to try to reduce the number of colors. It must be one of the following</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when an optimal solution has been found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes to have the same color. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in the graph, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors in the current solution.</p></li>
<li><p>3 : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes to be uncolored. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, as above.</p></li>
<li><p>None : No optimization is performed.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Only applicable when using <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>. The number of colors being used in a solution <code class="docutils literal notranslate"><span class="pre">c</span></code> is therefore <code class="docutils literal notranslate"><span class="pre">max(c.values())</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strategy</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">opt_alg</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.chromatic_number" title="gcol.coloring.chromatic_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chromatic_number</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.node_k_coloring" title="gcol.coloring.node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.edge_coloring" title="gcol.coloring.edge_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> with <span class="math notranslate nohighlight">\(n\)</span> nodes and <span class="math notranslate nohighlight">\(m\)</span> edges, the greedy algorithm for node coloring operates in <span class="math notranslate nohighlight">\(O(n + m)\)</span> time.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">random</span></code> strategy operates by first randomly permuting the nodes (an <span class="math notranslate nohighlight">\(O(n)\)</span> operation) before applying the greedy algorithm. It is guaranteed to produce a solution with <span class="math notranslate nohighlight">\(k \leq \Delta(G) + 1\)</span> colors, where <span class="math notranslate nohighlight">\(\Delta(G)\)</span> is the highest node degree in the graph <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">welsh-powell</span></code> strategy operates by sorting the nodes by decreasing degree (an <span class="math notranslate nohighlight">\(O(n \lg n)\)</span> operation), and then applies the greedy algorithm. Its overall complexity is therefore <span class="math notranslate nohighlight">\(O(n \lg n + m)\)</span>. Assuming that the nodes are labelled <span class="math notranslate nohighlight">\(v_1, v_2,\ldots,v_n\)</span> so that <span class="math notranslate nohighlight">\(\deg(v_1) \geq \deg(v_2) \geq \ldots \geq \deg(v_n)\)</span>, this method is guaranteed to produce a solution with <span class="math notranslate nohighlight">\(k \leq\max_{i=1,\ldots,n} \min(\deg(v_i)+1, i)\)</span> colors. This bound is an improvement on <span class="math notranslate nohighlight">\(\Delta(G) + 1\)</span>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dsatur</span></code> and <code class="docutils literal notranslate"><span class="pre">rlf</span></code> strategies are exact for bipartite, cycle, and wheel graphs (that is, solutions with the minimum number of colors are guaranteed). The implementation of <code class="docutils literal notranslate"><span class="pre">dsatur</span></code> uses a priority queue and has a complexity of <span class="math notranslate nohighlight">\(O(n \lg n + m \lg m)\)</span>. The <code class="docutils literal notranslate"><span class="pre">rlf</span></code> implementation has a complexity of <span class="math notranslate nohighlight">\(O(nm)\)</span>. In general, the <code class="docutils literal notranslate"><span class="pre">rlf</span></code> strategy yields the best solutions of the four strategies, though it is computationally more expensive. If expense is an issue, then <code class="docutils literal notranslate"><span class="pre">dsatur</span></code> is a cheaper alternative that also offers high-quality solutions in most cases. See <a class="reference internal" href="#rb30d7dff8300-2" id="id84">[2]</a>, <a class="reference internal" href="#rb30d7dff8300-3" id="id85">[3]</a>, and <a class="reference internal" href="#rb30d7dff8300-4" id="id86">[4]</a> for further information.</p>
<p>If an optimization algorithm is used, further efforts are made to reduce the number of colors. The backtracking approach (<code class="docutils literal notranslate"><span class="pre">opt_alg=1</span></code>) is an implementation of the exact algorithm described in <a class="reference internal" href="#rb30d7dff8300-4" id="id87">[4]</a>. It has exponential runtime and halts only when an optimum solution has been found. At the start of execution, a large clique <span class="math notranslate nohighlight">\(C\subseteq V\)</span> is identified using the NetworkX function <code class="docutils literal notranslate"><span class="pre">max_clique(G)</span></code> and the nodes of <span class="math notranslate nohighlight">\(C\)</span> are each assigned to a different color. The main backtracking algorithm is then executed and only halts only when a solution using <span class="math notranslate nohighlight">\(|C|\)</span> colors has been identified, or when the algorithm has backtracked to the root of the search tree. In both cases the returned solution will be optimal (that is, will be using <span class="math notranslate nohighlight">\(\chi(G)\)</span> colors).</p>
<p>If local search is used (<code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>), the algorithm removes a color class and uses the chosen local search routine to seek a proper coloring using the remaining colors. If this is successful, the process repeats. The algorithm is executed until a solution using <span class="math notranslate nohighlight">\(|C|\)</span> colors has been identified (as above), or until the iteration limit is reached. Fewer colors (but longer run times) occur with larger iteration limits.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code>, the TabuCol algorithm is used. This algorithm is based on tabu search and operates by fixing the number of colors but allowing clashes to occur (a clash is the occurrence of two adjacent nodes having the same color). The aim is to alter the color assignments so that the number of clashes is reduced to zero. Each iteration of TabuCol has complexity <span class="math notranslate nohighlight">\(O(nk + m)\)</span>, where <span class="math notranslate nohighlight">\(k\)</span> is the number of colors currently being used. The process also uses <span class="math notranslate nohighlight">\(O(nk + m)\)</span> memory.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>, the PartialCol algorithm is used. This algorithm is also based on tabu search and operates by fixing the number of colors but allowing some nodes to be left uncolored. The aim is to make alterations to the color assignments so that no uncolored nodes remain. As with TabuCol, each iteration of PartialCol has complexity <span class="math notranslate nohighlight">\(O(nk +m)\)</span> and uses <span class="math notranslate nohighlight">\(O(nk + m)\)</span> memory.</p>
<p>All the above algorithms and bounds are described in detail in <a class="reference internal" href="#rb30d7dff8300-4" id="id88">[4]</a>. The c++ code used in <a class="reference internal" href="#rb30d7dff8300-4" id="id89">[4]</a> and <a class="reference internal" href="#rb30d7dff8300-5" id="id90">[5]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb30d7dff8300-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id81">1</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Greedy Coloring &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Greedy_coloring">https://en.wikipedia.org/wiki/Greedy_coloring</a>&gt;</p>
</div>
<div class="citation" id="rb30d7dff8300-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id82">1</a>,<a role="doc-backlink" href="#id84">2</a>)</span>
<p>Wikipedia: DSatur &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/DSatur">https://en.wikipedia.org/wiki/DSatur</a>&gt;</p>
</div>
<div class="citation" id="rb30d7dff8300-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id83">1</a>,<a role="doc-backlink" href="#id85">2</a>)</span>
<p>Wikipedia: Recursive largest first (RLF) algorithm &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm">https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm</a>&gt;</p>
</div>
<div class="citation" id="rb30d7dff8300-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id86">1</a>,<a role="doc-backlink" href="#id87">2</a>,<a role="doc-backlink" href="#id88">3</a>,<a role="doc-backlink" href="#id89">4</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="rb30d7dff8300-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id90">5</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coloring is&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">Coloring is {0: 0, 1: 1, 19: 1, 10: 1, 2: 0, 3: 2, 8: 0, 9: 2, 18: 0, 11: 2, 6: 1, 7: 2, 4: 0, 5: 2, 13: 0, 12: 1, 14: 1, 15: 0, 16: 2, 17: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of colors =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Number of colors = 3</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Partition view =&quot;</span><span class="p">,</span> <span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="go">Partition view = [[0, 2, 8, 18, 4, 13, 15], [1, 19, 10, 6, 12, 14, 17], [3, 9, 11, 7, 5, 16]]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example with a larger graph and different parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">gnp_random_graph</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coloring is&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">Coloring is {18: 0, 31: 2, 2: 4, 20: 1, 10: 3, 46: 0, 49: 1, 29: 3, 37: 2, 9: 1, 7: 2, 33: 0, 21: 4, 26: 2, 5: 4, 16: 0, 41: 1, 39: 0, 13: 3, 14: 4, 17: 3, 28: 0, 35: 1, 42: 4, 4: 4, 11: 3, 3: 2, 48: 3, 40: 3, 0: 0, 30: 0, 6: 2, 8: 3, 25: 1, 34: 0, 44: 3, 24: 1, 1: 4, 47: 4, 15: 1, 23: 4, 32: 4, 45: 0, 22: 1, 43: 4, 36: 2, 19: 3, 12: 3, 38: 1, 27: 2}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of colors =&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Number of colors = 5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.node_k_coloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">node_k_coloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#node_k_coloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.node_k_coloring" title="Link to this definition">¶</a></dt>
<dd><p>Attempts to color the nodes of a graph using <code class="docutils literal notranslate"><span class="pre">k</span></code> colors so that adjacent nodes have different colors. A set of nodes assigned to the same color corresponds to an independent set; hence the equivalent aim is to partition the graph’s nodes into <code class="docutils literal notranslate"><span class="pre">k</span></code> independent sets.</p>
<p>Determining whether a node <span class="math notranslate nohighlight">\(k\)</span>-coloring exists for <span class="math notranslate nohighlight">\(G\)</span> is NP-complete. This method therefore includes options for using an exact exponential-time algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for larger values of <span class="math notranslate nohighlight">\(k\)</span>, for graphs that are small, or graphs that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</p>
<p>If a node <span class="math notranslate nohighlight">\(k\)</span>-coloring cannot be determined by the algorithm, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> exception is raised. Otherwise, a node <span class="math notranslate nohighlight">\(k\)</span>-coloring is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The nodes of this graph will be colored.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The number of colors to use.</p>
</dd>
<dt><strong>opt_alg</strong><span class="classifier">None or int, optional (default=None)</span></dt><dd><p>An integer specifying the optimization method that will be used to try to reduce the number of colors (if this is seen to be greater than <span class="math notranslate nohighlight">\(k\)</span>). It must be one of the following</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when the existence of a node <span class="math notranslate nohighlight">\(k\)</span>-coloring has been proved or disproved.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes to have the same color. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in the graph, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors in the current solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes to be uncolored. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, as above.</p></li>
<li><p>None : No optimization is performed.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Only applicable when using <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots,k-1\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">opt_alg</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.
If <code class="docutils literal notranslate"><span class="pre">k</span></code> is not a nonnegative integer.
If a clique larger than <code class="docutils literal notranslate"><span class="pre">k</span></code> is observed in the graph.
If a node <span class="math notranslate nohighlight">\(k\)</span>-coloring could not be determined.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.equitable_node_k_coloring" title="gcol.coloring.equitable_node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equitable_node_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.edge_k_coloring" title="gcol.coloring.edge_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_k_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This method begins by coloring the nodes in the order determined by the DSatur algorithm <a class="reference internal" href="#r254670b76db0-1" id="id96">[1]</a>. During this process, each node is assigned to the feasible color class <span class="math notranslate nohighlight">\(j\)</span> (where <span class="math notranslate nohighlight">\(0 \leq j \leq k\)</span>) with the fewest nodes. This encourages an equitable spread of nodes across the <span class="math notranslate nohighlight">\(k\)</span> colors. This process has a complexity of <span class="math notranslate nohighlight">\(O((n \lg n) + (nk) + (m \lg m)\)</span>. If a node <span class="math notranslate nohighlight">\(k\)</span>-coloring cannot be achieved in this way, further optimization is carried out, if desired. These optimization routines are the same as those used by the <a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_coloring()</span></code></a> method. They also halt immediately once a node <span class="math notranslate nohighlight">\(k\)</span>-coloring has been achieved.</p>
<p>All the above algorithms are described in detail in <a class="reference internal" href="#r254670b76db0-2" id="id97">[2]</a>. The c++ code used in <a class="reference internal" href="#r254670b76db0-2" id="id98">[2]</a> and <a class="reference internal" href="#r254670b76db0-3" id="id99">[3]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r254670b76db0-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id96">1</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: DSatur &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/DSatur">https://en.wikipedia.org/wiki/DSatur</a>&gt;</p>
</div>
<div class="citation" id="r254670b76db0-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id97">1</a>,<a role="doc-backlink" href="#id98">2</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="r254670b76db0-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id99">3</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">{0: 0, 1: 1, 19: 2, 10: 3, 2: 0, 3: 1, 8: 2, 9: 0, 18: 3, 11: 1, 6: 2, 4: 3, 5: 0, 7: 1, 13: 2, 12: 3, 14: 0, 17: 1, 16: 2, 15: 3}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">{0: 0, 1: 1, 19: 2, 10: 1, 2: 0, 3: 1, 8: 2, 9: 0, 18: 0, 11: 2, 6: 1, 7: 0, 4: 2, 5: 0, 17: 1, 13: 2, 14: 1, 15: 2, 16: 0, 12: 1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.node_precoloring">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">node_precoloring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dsatur'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_alg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">it_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#node_precoloring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.node_precoloring" title="Link to this definition">¶</a></dt>
<dd><p>Returns a coloring of a graph’s nodes in which some of the nodes have been precolored.</p>
<p>A node coloring of a graph is an assignment of colors to nodes so that adjacent nodes have different colors. The aim is to use as few colors as possible. A set of nodes assigned to the same color corresponds to an independent set; hence the equivalent aim is to partition the graph’s nodes into a minimum number of independent sets.</p>
<p>In the node precoloring problem, some of the nodes have already been assigned colors. The aim is to allocate colors to the remaining nodes so that we get a full, proper node coloring that uses a minimum number of colors. The node precoloring problem can be used to model the Latin square completion problem and Sudoku puzzles <a class="reference internal" href="#rf6f17d25a89d-1" id="id103">[1]</a>.</p>
<p>The node precoloring problem is NP-hard. This method therefore includes options for using an exponential-time exact algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for graphs that are small, or that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</p>
<p>In this implementation, solutions are found by taking all nodes pre-allocated to the same color <span class="math notranslate nohighlight">\(j\)</span> and merging them into a single super-node. Edges are then added between all pairs of super-nodes, and the modified graph is passed to the <a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_coloring()</span></code></a> method. All parameters are therefore the same as the latter. This modification process is described in more detail in Chapter 6 of <a class="reference internal" href="#rf6f17d25a89d-1" id="id104">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">NetworkX graph</span></dt><dd><p>The nodes of this graph will be colored.</p>
</dd>
<dt><strong>precol</strong><span class="classifier">None or dict, optional (default=None)</span></dt><dd><p>A dictionary that specifies the (integer) colors of any precolored nodes.</p>
</dd>
<dt><strong>strategy</strong><span class="classifier">string, optional (default=’dsatur’)</span></dt><dd><p>A string specifying the method used to generate the initial solution. It must be one of the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'random'</span></code> : Randomly orders the modified graph’s nodes and then applies the greedy algorithm for graph node coloring <a class="reference internal" href="#rf6f17d25a89d-2" id="id105">[2]</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'welsh-powell'</span></code> : Orders the modified graphs nodes by decreasing degree, then applies the greedy algorithm.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dsatur'</span></code> : Uses the DSatur algorithm for graph node coloring on the modified graph <a class="reference internal" href="#rf6f17d25a89d-3" id="id106">[3]</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'rlf'</span></code> : Uses the recursive largest first (RLF) algorithm for graph node coloring on the modified graph <a class="reference internal" href="#rf6f17d25a89d-4" id="id107">[4]</a>.</p></li>
</ul>
</dd>
<dt><strong>opt_alg</strong><span class="classifier">None or int, optional (default=None)</span></dt><dd><p>An integer specifying the optimization method that will be used to try to reduce the number of colors. It must be one of the following</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when an optimal solution has been found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes to have the same color. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in the modified graph, <span class="math notranslate nohighlight">\(m\)</span> is the number of edges, and <span class="math notranslate nohighlight">\(k\)</span> is the number of colors in the current solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code> : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes to be uncolored. Each iteration has a complexity <span class="math notranslate nohighlight">\(O(m + kn)\)</span>, as above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> : No optimization is performed.</p></li>
</ul>
</dd>
<dt><strong>it_limit</strong><span class="classifier">int, optional (default=0)</span></dt><dd><p>Number of iterations of the local search procedure. Only applicable when using <code class="docutils literal notranslate"><span class="pre">opt_alg=2</span></code> or <code class="docutils literal notranslate"><span class="pre">opt_alg=3</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dict</dt><dd><p>A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>. The number of colors being used in a solution <code class="docutils literal notranslate"><span class="pre">c</span></code> is therefore <code class="docutils literal notranslate"><span class="pre">max(c.values())</span> <span class="pre">+</span> <span class="pre">1</span></code>. If <code class="docutils literal notranslate"><span class="pre">precol[v]==j</span></code> then <code class="docutils literal notranslate"><span class="pre">c[v]==j</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">G</span></code> is a directed graph or a multigraph.</p>
</dd>
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">strategy</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">opt_alg</span></code> is not among the supported options.
If <code class="docutils literal notranslate"><span class="pre">it_limit</span></code> is not a nonnegative integer.
If <code class="docutils literal notranslate"><span class="pre">G</span></code> contains a node with the name <code class="docutils literal notranslate"><span class="pre">'super'</span></code>.
If <code class="docutils literal notranslate"><span class="pre">precol</span></code> contains a node that is not in <code class="docutils literal notranslate"><span class="pre">G</span></code>.
If <code class="docutils literal notranslate"><span class="pre">precol</span></code> contains a non-integer color label.
If <code class="docutils literal notranslate"><span class="pre">precol</span></code> contains a pair of adjacent nodes assigned the same color.
If <code class="docutils literal notranslate"><span class="pre">precol</span></code> uses an integer color label <span class="math notranslate nohighlight">\(j\)</span>, but there exists a color label <span class="math notranslate nohighlight">\(0 \leq i &lt; j\)</span> that is not being used.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.edge_precoloring" title="gcol.coloring.edge_precoloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_precoloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>As mentioned, in this implementation, solutions are formed by passing a modified version of the graph to <a class="reference internal" href="#gcol.coloring.node_coloring" title="gcol.coloring.node_coloring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">node_coloring()</span></code></a> method. All details are therefore the same as those in the latter, where they are documented.</p>
<p>All the above algorithms and bounds are described in detail in [1]. The c++ code used in <a class="reference internal" href="#rf6f17d25a89d-1" id="id108">[1]</a> and <a class="reference internal" href="#rf6f17d25a89d-5" id="id109">[5]</a> forms the basis of this library’s Python implementations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rf6f17d25a89d-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id103">1</a>,<a role="doc-backlink" href="#id104">2</a>,<a role="doc-backlink" href="#id108">3</a>)</span>
<p>Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;<a class="reference external" href="https://link.springer.com/book/10.1007/978-3-030-81054-2">https://link.springer.com/book/10.1007/978-3-030-81054-2</a>&gt;.</p>
</div>
<div class="citation" id="rf6f17d25a89d-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id105">2</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Greedy Coloring &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Greedy_coloring">https://en.wikipedia.org/wiki/Greedy_coloring</a>&gt;</p>
</div>
<div class="citation" id="rf6f17d25a89d-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id106">3</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: DSatur &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/DSatur">https://en.wikipedia.org/wiki/DSatur</a>&gt;</p>
</div>
<div class="citation" id="rf6f17d25a89d-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id107">4</a><span class="fn-bracket">]</span></span>
<p>Wikipedia: Recursive largest first (RLF) algorithm &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm">https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm</a>&gt;</p>
</div>
<div class="citation" id="rf6f17d25a89d-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id109">5</a><span class="fn-bracket">]</span></span>
<p>Lewis, R: Graph Colouring Algorithm User Guide &lt;<a class="reference external" href="https://rhydlewis.eu/gcol/">https://rhydlewis.eu/gcol/</a>&gt;</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_precoloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">precol</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coloring is&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">Coloring is {0: 1, 9: 1, 1: 2, 8: 0, 19: 2, 13: 2, 2: 1, 3: 0, 7: 1, 14: 0, 18: 1, 12: 1, 6: 2, 4: 1, 5: 0, 15: 1, 11: 2, 10: 0, 17: 2, 16: 0}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_precoloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">precol</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">{0: 0, 4: 4, 1: 1, 2: 2, 3: 3, 19: 4, 10: 4, 5: 0, 6: 4, 17: 0, 18: 1, 11: 0, 8: 0, 7: 1, 9: 1, 15: 4, 14: 0, 16: 1, 13: 4, 12: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="gcol.coloring.partition">
<span class="sig-prename descclassname"><span class="pre">gcol.coloring.</span></span><span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gcol/coloring.html#partition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#gcol.coloring.partition" title="Link to this definition">¶</a></dt>
<dd><p>Converts a coloring into its equivalent partition-based representation. Negative color labels (signifying uncolored nodes/edges) are ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys representing nodes or edges and values representing their colors. Colors are identified by the integers <span class="math notranslate nohighlight">\(0,1,2,\ldots\)</span>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>A list in which each element is a list containing the nodes/edges assigned to a particular color.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#gcol.coloring.equitable_node_k_coloring" title="gcol.coloring.equitable_node_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equitable_node_k_coloring</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#gcol.coloring.equitable_edge_k_coloring" title="gcol.coloring.equitable_edge_k_coloring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equitable_edge_k_coloring</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If all nodes in a color class are named by numerical values, the nodes are sorted in ascending order. Otherwise, the nodes of each color class are sorted by their string equivalents.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gcol</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dodecahedral_graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">node_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="go">[[0, 2, 8, 18, 4, 13, 15], [1, 19, 10, 6, 12, 14, 17], [3, 9, 11, 7, 5, 16]]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">gcol</span><span class="o">.</span><span class="n">edge_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gcol</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="go">[[(11, 12), (18, 19), (16, 17), (0, 10), (9, 13), (14, 15), (3, 4), (1, 2), (5, 6), (7, 8)], [(11, 18), (12, 16), (4, 17), (9, 10), (13, 14), (5, 15), (0, 19), (2, 3), (1, 8), (6, 7)], [(10, 11), (12, 13), (17, 18), (15, 16), (8, 9), (7, 14), (3, 19), (0, 1), (2, 6), (4, 5)]]</span>
</pre></div>
</div>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">5. Documentation</a><ul>
<li><a class="reference internal" href="#gcol.coloring.chromatic_index"><code class="docutils literal notranslate"><span class="pre">chromatic_index()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.chromatic_number"><code class="docutils literal notranslate"><span class="pre">chromatic_number()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.coloring_layout"><code class="docutils literal notranslate"><span class="pre">coloring_layout()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.edge_coloring"><code class="docutils literal notranslate"><span class="pre">edge_coloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.edge_k_coloring"><code class="docutils literal notranslate"><span class="pre">edge_k_coloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.edge_precoloring"><code class="docutils literal notranslate"><span class="pre">edge_precoloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.equitable_edge_k_coloring"><code class="docutils literal notranslate"><span class="pre">equitable_edge_k_coloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.equitable_node_k_coloring"><code class="docutils literal notranslate"><span class="pre">equitable_node_k_coloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.get_edge_colors"><code class="docutils literal notranslate"><span class="pre">get_edge_colors()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.get_node_colors"><code class="docutils literal notranslate"><span class="pre">get_node_colors()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.get_set_colors"><code class="docutils literal notranslate"><span class="pre">get_set_colors()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.kempe_chain"><code class="docutils literal notranslate"><span class="pre">kempe_chain()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.max_independent_set"><code class="docutils literal notranslate"><span class="pre">max_independent_set()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.min_cost_k_coloring"><code class="docutils literal notranslate"><span class="pre">min_cost_k_coloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.multipartite_layout"><code class="docutils literal notranslate"><span class="pre">multipartite_layout()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.node_coloring"><code class="docutils literal notranslate"><span class="pre">node_coloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.node_k_coloring"><code class="docutils literal notranslate"><span class="pre">node_k_coloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.node_precoloring"><code class="docutils literal notranslate"><span class="pre">node_precoloring()</span></code></a></li>
<li><a class="reference internal" href="#gcol.coloring.partition"><code class="docutils literal notranslate"><span class="pre">partition()</span></code></a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="performance/Performance.html"
                          title="previous chapter"><span class="section-number">4. </span>Performance Analysis</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/modules.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="performance/Performance.html" title="4. Performance Analysis"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GCol 0.0.4 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5. </span>Documentation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, R. Lewis.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>