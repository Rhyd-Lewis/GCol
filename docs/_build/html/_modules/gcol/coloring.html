<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gcol.coloring &#8212; GCol 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinxdoc.css?v=34905f61" />
    <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">GCol 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gcol.coloring</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gcol.coloring</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">gcol.equitable_node_coloring</span> <span class="k">as</span> <span class="nn">enc</span>
<span class="kn">import</span> <span class="nn">gcol.node_coloring</span> <span class="k">as</span> <span class="nn">nc</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">_RGBList</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">192</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">192</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">192</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">192</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">192</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">192</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">192</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">192</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">96</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">96</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">96</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">96</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">160</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">160</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">160</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">160</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">160</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">160</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">224</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">224</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">),</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">):</span>
    <span class="n">greedy_methods</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="s2">&quot;welsh_powell&quot;</span><span class="p">,</span> <span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="s2">&quot;rlf&quot;</span><span class="p">}</span>
    <span class="n">opt_methods</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">strategy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">greedy_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, chosen strategy must be one of&quot;</span><span class="p">,</span> <span class="n">greedy_methods</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">opt_alg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">opt_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, chosen optimisation method must be one of&quot;</span><span class="p">,</span> <span class="n">opt_methods</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Error, this method cannot be used with directed graphs or multigraphs&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">it_limit</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">it_limit</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, it_limit parameter must be a non-negative integer&quot;</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_all_numeric</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># Returns True iff all items in the list are numeric values</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_getNodeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
    <span class="c1"># Puts all node weights into a dict W</span>
    <span class="n">W</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">weight</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Error, all nodes must feature the property&quot;</span><span class="p">,</span> <span class="n">weight</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, all node weights must be positive&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span>


<span class="k">def</span> <span class="nf">_getEdgeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
    <span class="c1"># Puts all edge weights into a dict</span>
    <span class="n">W</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">weight</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Error, all edges must feature the property&quot;</span><span class="p">,</span> <span class="n">weight</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, all edge weights must be postive&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span>


<div class="viewcode-block" id="partition">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.partition">[docs]</a>
<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts a coloring into its equivalent partition-based representation. Negative color labels (signifying uncolored nodes/edges) are ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : dict</span>
<span class="sd">        A dictionary with keys representing nodes or edges and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list in which each element is a list containing the nodes/edges assigned to a particular color.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; print(gcol.partition(c))</span>
<span class="sd">    [[0, 2, 8, 18, 4, 13, 15], [1, 19, 10, 6, 12, 14, 17], [3, 9, 11, 7, 5, 16]]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.edge_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; print(gcol.partition(c))</span>
<span class="sd">    [[(11, 12), (18, 19), (16, 17), (0, 10), (9, 13), (14, 15), (3, 4), (1, 2), (5, 6), (7, 8)], [(11, 18), (12, 16), (4, 17), (9, 10), (13, 14), (5, 15), (0, 19), (2, 3), (1, 8), (6, 7)], [(10, 11), (12, 13), (17, 18), (15, 16), (8, 9), (7, 14), (3, 19), (0, 1), (2, 6), (4, 5)]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If all nodes in a color class are named by numerical values, the nodes are sorted in ascending order. Otherwise, the nodes of each color class are sorted by their string equivalents.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    equitable_node_k_coloring</span>
<span class="sd">    equitable_edge_k_coloring</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">S</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_all_numeric</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">S</span></div>



<div class="viewcode-block" id="coloring_layout">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.coloring_layout">[docs]</a>
<span class="k">def</span> <span class="nf">coloring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Arranges the nodes of the graph in a circle so that nodes of the same color are next to each other. This method is designed to be used with the ``pos`` argument in the drawing functions of NetworkX (see example below).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph we want to visualize.</span>

<span class="sd">    c : dict</span>
<span class="sd">        A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$. Nodes with negative values are ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pos : dict</span>
<span class="sd">        A dictionary of positions keyed by node.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; nx.draw_networkx(G, pos=gcol.coloring_layout(G, c), node_color=gcol.get_node_colors(G, c))</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_node_colors</span>
<span class="sd">    multipartite_layout</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">GCopy</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">GCopy</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">GCopy</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="n">GCopy</span><span class="p">)</span></div>



<div class="viewcode-block" id="multipartite_layout">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.multipartite_layout">[docs]</a>
<span class="k">def</span> <span class="nf">multipartite_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Arranges the nodes of the graph into columns so that those of the same color are in the same column. This method is designed to be used with the ``pos`` argument in the drawing functions of NetworkX (see example below).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph we want to visualize.</span>

<span class="sd">    c : dict</span>
<span class="sd">        A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$. Nodes with negative color labels are ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pos : dict</span>
<span class="sd">        A dictionary of positions keyed by node.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; nx.draw_networkx(G, pos=gcol.multipartite_layout(G, c), node_color=gcol.get_node_colors(G, c))</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_node_colors</span>
<span class="sd">    coloring_layout</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">GCopy</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">GCopy</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">GCopy</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">multipartite_layout</span><span class="p">(</span><span class="n">GCopy</span><span class="p">,</span> <span class="n">subset_key</span><span class="o">=</span><span class="s2">&quot;layer&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_node_colors">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.get_node_colors">[docs]</a>
<span class="k">def</span> <span class="nf">get_node_colors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates an RGB color for each node in the graph ``G`` based on its color label in ``c``. This method is designed to be used with the ``node_color`` argument in the drawing functions of NetworkX (see example below). If a node is marked as uncolored (i.e., assigned a negative value, or not present in ``c``), it is painted white.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph we want to visualize.</span>

<span class="sd">    c : dict</span>
<span class="sd">        A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list specifying the RGB color that each node should be painted with.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; nx.draw_networkx(G, pos=nx.spring_layout(G), node_color=gcol.get_node_colors(G, c))</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``c`` uses more than 56 colors.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Color 0 is set to red; color 1, green; and color, 2 blue. Beyond this, a sequence of RGB values are generated for each integer, aiming to keep the presented colors as distict as possible. </span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_set_colors</span>
<span class="sd">    get_edge_colors</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">_RGBList</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error too many colors to create a color map that can be usefully visualized&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span>
                <span class="n">_RGBList</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span>
                <span class="n">_RGBList</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span>
                <span class="n">_RGBList</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]][</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span>
    <span class="p">]</span></div>



<div class="viewcode-block" id="get_edge_colors">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.get_edge_colors">[docs]</a>
<span class="k">def</span> <span class="nf">get_edge_colors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates an RGB color for each edge in the graph ``G`` based on its color label in ``c``. This method is designed to be used with the ``edge_color`` argument in the drawing functions of NetworkX (see example below). If an edge is marked as uncolored (i.e., assigned a negative value, or not present in ``c``), it is painted light grey.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph we want to visualize.</span>

<span class="sd">    c : dict</span>
<span class="sd">        A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list specifying the RGB color that each edge should be painted with.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.edge_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; nx.draw_networkx(G, pos=nx.spring_layout(G), edge_color=gcol.get_edge_colors(G, c))</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``c`` uses more than 56 colors.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Color 0 is set to red; color 1, green; and color, 2 blue. Beyond this, a sequence of RGB values are generated for each integer, aiming to keep the presented colors as distict as possible. </span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_set_colors</span>
<span class="sd">    get_node_colors</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">_RGBList</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error too many colors to create a color map that can be usefully visualized&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">(</span>
            <span class="p">(</span>
                <span class="n">_RGBList</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">e</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span>
                <span class="n">_RGBList</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">e</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span>
                <span class="n">_RGBList</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">e</span><span class="p">]][</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="p">(</span><span class="mi">211</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="mi">211</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="mi">211</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span>
    <span class="p">]</span></div>



<div class="viewcode-block" id="get_set_colors">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.get_set_colors">[docs]</a>
<span class="k">def</span> <span class="nf">get_set_colors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">S_color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="n">other_color</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates an RGB color for each node in the graph based on whether it is a member of the set ``S``. By default, nodes in ``S`` are painted yellow and all others are painted grey. This method is designed to be used with the ``node_color`` argument in the drawing functions of NetworkX (see example below).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph we want to visualize.</span>

<span class="sd">    S : list or set</span>
<span class="sd">        A subset of ``G``&#39;s nodes.</span>

<span class="sd">    S_color : color, optional (default=&#39;yellow&#39;)</span>
<span class="sd">        Desired color of the nodes in ``S``. Other options include ``&#39;blue&#39;``, ``&#39;cyan&#39;``, ``&#39;green&#39;``, ``&#39;black&#39;``, ``&#39;magenta&#39;``, ``&#39;red&#39;``, ``&#39;white&#39;``, and ``&#39;yellow&#39;``.</span>

<span class="sd">    other_color : color, optional (default=&#39;grey&#39;)</span>
<span class="sd">        Desired color of the nodes not in ``S``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list specifying the RGB color that each node should be painted with.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; S = gcol.max_independent_set(G, it_limit=1000)</span>
<span class="sd">    &gt;&gt;&gt; nx.draw_networkx(G, pos=nx.spring_layout(G), node_color=gcol.get_set_colors(G, S))</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_node_colors</span>
<span class="sd">    get_edge_colors</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">S_color</span> <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">I</span> <span class="k">else</span> <span class="n">other_color</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span></div>



<div class="viewcode-block" id="kempe_chain">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.kempe_chain">[docs]</a>
<span class="k">def</span> <span class="nf">kempe_chain</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a node coloring ``c`` of a graph ``G``, this method returns the set of nodes in the Kempe chain generated from a source node ``s`` using the color ``j``.</span>

<span class="sd">    A Kempe chain is a connected set of nodes in a graph that alternates between two colors [1]_. Equivalently, it is a maximal connected subgraph that contains nodes of at most two colors. Interchanging the colors of the nodes in a Kempe chain creates a new coloring that uses the same number of colors or one fewer color. Two $k$-colorings of a graph are considered *Kempe equivalent* if one can be obtained from the other through a series of Kempe chain interchanges [2]_. It is also known that, if $k$ is larger than the degeneracy of a graph, then all $k$-colorings of this graph are Kempe equivalent [2]_. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph that we want to compute a Kempe chain for.</span>

<span class="sd">    c : dict</span>
<span class="sd">        A node coloring of ``G``. Pairs of adjacent nodes cannot be allocated to the same color. Any uncolored nodes ``u`` should have ``c[u]==-1``.</span>

<span class="sd">    s : node</span>
<span class="sd">        The source node that we will generate the Kempe chain from.</span>

<span class="sd">    j : int</span>
<span class="sd">        The second color to use. The first color is that of ``s``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set</span>
<span class="sd">        The set of nodes, reachable from ``s``, that alternate between colors ``i`` and ``j`` (where ``c[s]==i``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; S = gcol.kempe_chain(G, c, 0, 1)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Example Kempe chain =&quot;, S)</span>
<span class="sd">    Example Kempe chain = {0, 1, 2, 4, 6, 8, 10, 17, 18, 19}</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``c`` contains a pair of adjacent nodes assigned to the same color.</span>
<span class="sd">        If ``c`` contains an invalid color label or no color label for ``s``.</span>
<span class="sd">        If ``G`` contains a node that is not in ``c``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method uses an extension of breadth-first search and operates in $O(n+m)$ time. If ``c[s]==j``, then the Kempe chain contains node ``s`` only.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    equitable_node_k_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: Kempe Chain &lt;https://en.wikipedia.org/wiki/Kempe_chain&gt;</span>
<span class="sd">    .. [2] Cranston, D. (2024) Graph Coloring Methods &lt;https://graphcoloringmethods.com/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Error, this method cannot be used with directed graphs or multigraphs&quot;</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Error, the graph cannot contain adjacent nodes of the same color. Also, uncolored nodes v must have c[v] == -1&quot;</span>
                <span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span> <span class="ow">or</span> <span class="n">c</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, node s must be present in the graph and assigned a color&quot;</span>
        <span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">s</span><span class="p">}</span>
    <span class="c1"># If we are here, use bredth-first search to identify the Kempe chain</span>
    <span class="n">status</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">s</span><span class="p">])</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
                    <span class="n">status</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">Q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">status</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">Chain</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Chain</span></div>



<div class="viewcode-block" id="max_independent_set">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.max_independent_set">[docs]</a>
<span class="k">def</span> <span class="nf">max_independent_set</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempts to identify the largest independent set of nodes in a graph. Nodes can also be allocated weights if desired.</span>

<span class="sd">    The maximum independent set in a graph $G$ is the largest subset of nodes in which none are adjacent. The size of the largest independent in a graph $G$ is known as the independence number of $G$ and is often denoted by $\\alpha(G)$. Similarly, the maximum-weighted independent set in $G$ is the subset of mutually nonadjacent nodes whose weight-total is maximized.</span>

<span class="sd">    The problem of determining a maximum(-weighted) independent set of nodes is NP-hard. Consequently, this method makes use of a polynomial-time heuristic based on local search. It will always return an independent set but offers no guarantees on whether this is the optimal solution. The algorithm halts once the iteration limit has been reached.</span>

<span class="sd">    Note that the similar problem of determining the maximum(-weighted) independent set of edges is equivalent to finding a maximum(-weighted) matching in a graph. This is a polynomially solvable problem and can be solved by the Blossom algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        An independent set of nodes in this graph will be returned.</span>

<span class="sd">    weight : None or string, optional (default=None)</span>
<span class="sd">        If ``None``, every node is assumed to have a weight of ``1``. If a string, this should correspond to a defined node attribute. All node weights must be positive.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Each iteration has a complexity $O(m + n)$, where $n$ is the number of nodes and $m$ is the number of edges.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list containing the nodes belonging to the independent set.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; S = gcol.max_independent_set(G, it_limit=1000)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Independent set =&quot;, S)</span>
<span class="sd">    Independent set = [19, 10, 2, 8, 5, 12, 14, 17]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Do similar with a node-weighted graph</span>
<span class="sd">    &gt;&gt;&gt; G = nx.Graph()</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(0, weight=20)</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(1, weight=9)</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(2, weight=25)</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(3, weight=10)</span>
<span class="sd">    &gt;&gt;&gt; G.add_edges_from([(0,2), (1,2), (3, 2)])</span>
<span class="sd">    &gt;&gt;&gt; S = gcol.max_independent_set(G, weight=&quot;weight&quot;, it_limit=1000)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Independent set =&quot;, S)</span>
<span class="sd">    Independent set = [0, 1, 3]</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>
<span class="sd">        If a node with a non-positive weight is specified.</span>

<span class="sd">    KeyError</span>
<span class="sd">        If a node does not have the attribute defined by ``weight``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method uses the PartialCol algorithm for node $k$-coloring using $k=1$. The set of nodes assigned to this color corresponds to the independent set. PartialCol is based on tabu search. Here, each iteration of PartialCol has complexity $O(n + m)$. It also occupies $O(n + m)$ of memory space.</span>

<span class="sd">    The above algorithm is described in detail in [1]_. The c++ code used in [1]_ and [2]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    node_k_coloring</span>
<span class="sd">    node_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [2] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">_getNodeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
    <span class="c1"># Make an initial coloring via dsatur and uncolor all but the first color</span>
    <span class="c1"># class</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_dsatur</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">cost</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">its</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_partialcol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="min_cost_k_coloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.min_cost_k_coloring">[docs]</a>
<span class="k">def</span> <span class="nf">min_cost_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights_at</span><span class="o">=</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Colors the nodes of the graph using ``k`` colors so that a cost function is minimized. Equivalently, this routine partitions a graph&#39;s nodes while attempting to minimize a specific cost function.</span>

<span class="sd">    This routine will always produce a $k$-coloring. However, this solution may include some clashes (that is, instances of adjacent nodes having the same color), or uncolored nodes. The aim is to minimize the number (or total weight) of these occurrences.</span>

<span class="sd">    Determining a minimum cost solution to these problems is NP-hard. This routine employs polynomial-time heuristic algorithms based on local search.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The nodes of this graph will be colored.</span>

<span class="sd">    k : int</span>
<span class="sd">        The number of colors to use.</span>

<span class="sd">    weight : None or string, optional (default=None)</span>
<span class="sd">        If ``None``, every node and edge is assumed to have a weight of ``1``. If string, this should correspond to a defined node or edge attribute. All node and edge weights must be positive.</span>

<span class="sd">    weights_at : string, optional (default=&#39;nodes&#39;)</span>
<span class="sd">        A string that must be one of the following:</span>

<span class="sd">        * ``&#39;nodes&#39;`` : Here, nodes can be left uncolored in a solution. If ``weight=None``, the method seeks a $k$-coloring in which the number of uncolored nodes is minimized; otherwise, the method seeks a $k$-coloring that minimizes the sum of the weights of the uncolored nodes. Clashes are not permitted in a solution. The algorithm halts when a zero-cost solution has been determined (this corresponds to a full, proper node $k$-coloring), or when the iteration limit is reached.</span>
<span class="sd">        * ``&#39;edges&#39;`` : Here, clashes are permitted in a solution. If ``weight=None``, the method seeks a $k$-coloring in which the number of clashes is minimized; otherwise, the method seeks a coloring that minimizes the sum of the weights of edges involved in a clash. Uncolored nodes are not permitted in a solution. The algorithm halts when a zero-cost solution has been determined (this corresponds to a full, proper node $k$-coloring), or when the iteration limit is reached.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes, $m$ is the number of edges, and $k$ is the number of colors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots,k-1$. Uncolored nodes are given a value of ``-1``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Unweighted graph</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.min_cost_k_coloring(G, 2, weights_at=&quot;nodes&quot;, it_limit=1000)</span>
<span class="sd">    &gt;&gt;&gt; P = gcol.partition(c)</span>
<span class="sd">    &gt;&gt;&gt; print(P)</span>
<span class="sd">    [[0, 2, 8, 18, 4, 13, 15], [1, 19, 10, 6, 12, 14, 17]]</span>
<span class="sd">    &gt;&gt;&gt; for u in G:</span>
<span class="sd">    &gt;&gt;&gt;     if c[u] == -1:</span>
<span class="sd">    &gt;&gt;&gt;         print(&quot;Node&quot;, u, &quot;is not colored&quot;)</span>
<span class="sd">    Node 3 is not colored</span>
<span class="sd">    Node 5 is not colored</span>
<span class="sd">    Node 7 is not colored</span>
<span class="sd">    Node 9 is not colored</span>
<span class="sd">    Node 11 is not colored</span>
<span class="sd">    Node 16 is not colored</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Edge-weighted graph (arbitrary weights)</span>
<span class="sd">    &gt;&gt;&gt; for e in G.edges():</span>
<span class="sd">    &gt;&gt;&gt;     G.add_edge(e[0], e[1], weight = abs(e[0]-e[1]))</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.min_cost_k_coloring(G, 2, weights_at=&quot;edges&quot;, it_limit=1000)</span>
<span class="sd">    &gt;&gt;&gt; P = gcol.partition(c)</span>
<span class="sd">    &gt;&gt;&gt; print(P)</span>
<span class="sd">    [[0, 2, 8, 18, 11, 7, 4, 13, 15, 16], [1, 19, 10, 3, 9, 6, 5, 12, 14, 17]]</span>
<span class="sd">    &gt;&gt;&gt; for u, v in G.edges():</span>
<span class="sd">    &gt;&gt;&gt;     if c[u] == c[v]:</span>
<span class="sd">    &gt;&gt;&gt;         print(&quot;Edge&quot;, u, v, &quot;( cost =&quot;, G[u][v][&quot;weight&quot;], &quot;) is clashing &quot;)</span>
<span class="sd">    Edge 3 19 ( cost = 16 ) is clashing</span>
<span class="sd">    Edge 5 6 ( cost = 1 ) is clashing</span>
<span class="sd">    Edge 7 8 ( cost = 1 ) is clashing</span>
<span class="sd">    Edge 9 10 ( cost = 1 ) is clashing</span>
<span class="sd">    Edge 11 18 ( cost = 7 ) is clashing</span>
<span class="sd">    Edge 15 16 ( cost = 1 ) is clashing</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``weights_at`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>
<span class="sd">        If ``k`` is not a nonnegative integer.</span>
<span class="sd">        If a node/edge with a non-positive weight is specified.</span>

<span class="sd">    KeyError</span>
<span class="sd">        If ``weights_at==&#39;nodes&#39;`` and a node does not have the attribute defined by ``weight``.</span>
<span class="sd">        If ``weights_at==&#39;edges&#39;`` and an edge does not have the attribute defined by ``weight``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If ``weights_at=&#39;edges&#39;``, the TabuCol algorithm is used. This algorithm is based on tabu search and operates using $k$ colors, allowing clashes to occur. The aim is to alter the color assignments so that the number of clashes (or the total weight of all clashing edges) is minimized. Each iteration of TabuCol has complexity $O(nk + m)$. The process also uses $O(nk + m)$ memory.</span>

<span class="sd">    If ``weights_at=&#39;nodes&#39;``, the PartialCol algorithm is used. This algorithm is also based on tabu search and operates using $k$ colors, allowing some nodes to be left uncolored. The aim is to make alterations to the color assignments so that the number of uncolored nodes (or the total weight of the uncolored nodes) is minimized. As with TabuCol, each iteration of PartialCol has complexity $O(nk +m)$. This process also uses $O(nk + m)$ memory.</span>

<span class="sd">    All the above algorithms are described in detail in [1]_. The c++ code used in [1]_ and [2]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    node_k_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [2] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, nonnegative integer needed for k&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weights_at</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span> <span class="s2">&quot;edges&quot;</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, weights_at should be either &#39;nodes&#39; or &#39;edges&#39;&quot;</span>
        <span class="p">)</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_dsatur</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weights_at</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">_getNodeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">cost</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">its</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_partialcol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">_getEdgeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cost</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">its</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_tabucol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span></div>



<div class="viewcode-block" id="equitable_node_k_coloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.equitable_node_k_coloring">[docs]</a>
<span class="k">def</span> <span class="nf">equitable_node_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempts to color the nodes of a graph using ``k`` colors so that (a) all adjacent nodes have different colors, and (b) the weight of each color class is equal. If ``weight=None``, the weight of a color class is the number of nodes assigned to that color; otherwise, it is the sum of the weights of the nodes assigned to that color.</span>

<span class="sd">    Equivalently, this routine seeks to partition the graph&#39;s nodes into ``k`` independent sets so that the weight of each independent set is equal.</span>

<span class="sd">    Determining an equitable node $k$-coloring is NP-hard. This method first follows the steps used by the :meth:`node_k_coloring` method to try and find a node $k$-coloring. If this is achieved, the algorithm then uses a bespoke local search operator to reduce the variance in weights across the $k$ colors.</span>

<span class="sd">    If a node $k$-coloring cannot be determined by the algorithm, a ``ValueError`` exception is raised. Otherwise, a node $k$-coloring is returned in which the variance in weights across the $k$ color classes has been minimized. In solutions returned by this method, neighboring nodes always receive different colors; however, the coloring is not guaranteed to be equitable, even if an equitable node $k$-coloring exists.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The nodes of this graph will be colored.</span>

<span class="sd">    k : int</span>
<span class="sd">        The number of colors to use.</span>

<span class="sd">    weight : None or string, optional (default=None)</span>
<span class="sd">        If ``None``, every node is assumed to have a weight of ``1``. If string, this should correspond to a defined node attribute. Node weights must be positive.</span>

<span class="sd">    opt_alg : int, optional (default=None)</span>
<span class="sd">        An integer specifying the optimization method that will be used to try to reduce the number of colors (if this is seen to be greater than $k$). It must be one of the following</span>

<span class="sd">        * ``1`` : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when the existence of a node $k$-coloring has been proved or disproved.</span>
<span class="sd">        * ``2`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes to have the same color. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes in the modified graph, $m$ is the number of edges, and $k$ is the number of colors in the current solution.</span>
<span class="sd">        * ``3`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes to be uncolored. Each iteration has a complexity $O(m + kn)$, as above.</span>
<span class="sd">        * ``None`` : No optimization is performed.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Only applicable when using ``opt_alg=2`` or ``opt_alg=3``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots,k-1$.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.equitable_node_k_coloring(G, 4)</span>
<span class="sd">    &gt;&gt;&gt; P = gcol.partition(c)</span>
<span class="sd">    &gt;&gt;&gt; print(P)</span>
<span class="sd">    [[0, 2, 9, 5, 14], [1, 3, 11, 7, 17], [19, 8, 6, 13, 16], [10, 18, 4, 12, 15]]</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Size of smallest color class =&quot;, min(len(j) for j in P))</span>
<span class="sd">    Size of smallest color class = 5</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Size of biggest color class =&quot;, max(len(j) for j in P))</span>
<span class="sd">    Size of biggest color class = 5</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; #Now do similar with a node-weighted graph</span>
<span class="sd">    &gt;&gt;&gt; G = nx.Graph()</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(0, weight=20)</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(1, weight=9)</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(2, weight=25)</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(3, weight=10)</span>
<span class="sd">    &gt;&gt;&gt; G.add_edges_from([(0,2), (1,2), (3, 2)])</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.equitable_node_k_coloring(G, 3, weight=&quot;weight&quot;)</span>
<span class="sd">    &gt;&gt;&gt; P = gcol.partition(c)</span>
<span class="sd">    &gt;&gt;&gt; print(P)</span>
<span class="sd">    [[2], [0], [1, 3]]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Weight of lightest color class =&quot;, min(sum(G.nodes[v][&#39;weight&#39;] for v in j) for j in P))</span>
<span class="sd">    Weight of lightest color class = 19</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Weight of heaviest color class =&quot;, max(sum(G.nodes[v][&#39;weight&#39;] for v in j) for j in P))</span>
<span class="sd">    Weight of heaviest color class = 25</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``opt_alg`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>
<span class="sd">        If ``k`` is not a nonnegative integer.</span>
<span class="sd">        If a clique larger than ``k`` is observed in the graph.</span>
<span class="sd">        If a node $k$-coloring could not be determined.</span>
<span class="sd">        If a node with a non-positive weight is specified.</span>

<span class="sd">    KeyError</span>
<span class="sd">        If a node does not have the attribute defined by ``weight``</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method first follows the same steps as the :meth:`node_k_coloring` method to try and find a node $k$-coloring; however, it also takes node weights into account if needed. If a node $k$-coloring is achieved, a bespoke local search operator (based on steepest descent) is then used to try to reduce the variance in weights across the $k$ color classes. This process involves evaluating each Kempe-chain interchange in the current solution [1]_ and performing the interchange that results in the largest reduction in variance. This process repeats until there are no interchanges that reduce the variance. Each iteration of this local search process takes $O(n^2)$ time. Further details on this optimization method can be found in Chapter 7 of [2], or in [3]_.</span>

<span class="sd">    All the above algorithms are described in detail in [2]_. The c++ code used in [2]_ and [4]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    node_k_coloring</span>
<span class="sd">    equitable_edge_k_coloring</span>
<span class="sd">    kempe_chain</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: Kempe Chain &lt;https://en.wikipedia.org/wiki/Kempe_chain&gt;</span>
<span class="sd">    .. [2] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [3] Lewis, R. and F. Carroll (2016) &#39;Creating Seating Plans: A Practical Application&#39;. Journal of the Operational Research Society, vol. 67(11), pp. 1353-1362.</span>
<span class="sd">    .. [4] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, nonnegative integer needed for k&quot;</span><span class="p">)</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">cliqueNum</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">approximation</span><span class="o">.</span><span class="n">large_clique_size</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cliqueNum</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, a clique of size greater than k exists in the graph, so a k-coloring is not possible. Try increasing k&quot;</span>
        <span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">_getNodeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">_dsatur_equitable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opt_alg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, a k-coloring could not be found. Try changing the optimisation options or increasing k&quot;</span>
            <span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_dsatur</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opt_alg</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">WPrime</span> <span class="o">=</span> <span class="n">_getEdgeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">WPrime</span> <span class="o">=</span> <span class="n">_getNodeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_reducecolors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">WPrime</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, could not construct a k-coloring of this graph. Try increasing k or using more optimisation&quot;</span>
            <span class="p">)</span>
    <span class="c1"># If we are here we have a k-coloring. Attempt to decrease the variance</span>
    <span class="c1"># across the color classes using a steepest descent heuristic</span>
    <span class="k">return</span> <span class="n">enc</span><span class="o">.</span><span class="n">_LS_equitable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span></div>



<div class="viewcode-block" id="node_k_coloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.node_k_coloring">[docs]</a>
<span class="k">def</span> <span class="nf">node_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempts to color the nodes of a graph using ``k`` colors so that adjacent nodes have different colors. A set of nodes assigned to the same color corresponds to an independent set; hence the equivalent aim is to partition the graph&#39;s nodes into ``k`` independent sets.</span>

<span class="sd">    Determining whether a node $k$-coloring exists for $G$ is NP-complete. This method therefore includes options for using an exact exponential-time algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for larger values of $k$, for graphs that are small, or graphs that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</span>

<span class="sd">    If a node $k$-coloring cannot be determined by the algorithm, a ``ValueError`` exception is raised. Otherwise, a node $k$-coloring is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The nodes of this graph will be colored.</span>

<span class="sd">    k : int</span>
<span class="sd">        The number of colors to use.</span>

<span class="sd">    opt_alg : None or int, optional (default=None)</span>
<span class="sd">        An integer specifying the optimization method that will be used to try to reduce the number of colors (if this is seen to be greater than $k$). It must be one of the following</span>

<span class="sd">        * ``1`` : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when the existence of a node $k$-coloring has been proved or disproved.</span>
<span class="sd">        * ``2`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes to have the same color. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes in the graph, $m$ is the number of edges, and $k$ is the number of colors in the current solution.</span>
<span class="sd">        * ``3`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes to be uncolored. Each iteration has a complexity $O(m + kn)$, as above.</span>
<span class="sd">        * None : No optimization is performed.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Only applicable when using ``opt_alg=2`` or ``opt_alg=3``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots,k-1$.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_k_coloring(G, 4)</span>
<span class="sd">    &gt;&gt;&gt; print(c)</span>
<span class="sd">    {0: 0, 1: 1, 19: 2, 10: 3, 2: 0, 3: 1, 8: 2, 9: 0, 18: 3, 11: 1, 6: 2, 4: 3, 5: 0, 7: 1, 13: 2, 12: 3, 14: 0, 17: 1, 16: 2, 15: 3}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_k_coloring(G, 3)</span>
<span class="sd">    &gt;&gt;&gt; print(c)</span>
<span class="sd">    {0: 0, 1: 1, 19: 2, 10: 1, 2: 0, 3: 1, 8: 2, 9: 0, 18: 0, 11: 2, 6: 1, 7: 0, 4: 2, 5: 0, 17: 1, 13: 2, 14: 1, 15: 2, 16: 0, 12: 1}</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``opt_alg`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>
<span class="sd">        If ``k`` is not a nonnegative integer.</span>
<span class="sd">        If a clique larger than ``k`` is observed in the graph.</span>
<span class="sd">        If a node $k$-coloring could not be determined.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method begins by coloring the nodes in the order determined by the DSatur algorithm [1]_. During this process, each node is assigned to the feasible color class $j$ (where $0 \\leq j \\leq k$) with the fewest nodes. This encourages an equitable spread of nodes across the $k$ colors. This process has a complexity of $O((n \\lg n) + (nk) + (m \\lg m)$. If a node $k$-coloring cannot be achieved in this way, further optimization is carried out, if desired. These optimization routines are the same as those used by the :meth:`node_coloring` method. They also halt immediately once a node $k$-coloring has been achieved.</span>

<span class="sd">    All the above algorithms are described in detail in [2]_. The c++ code used in [2]_ and [3]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    node_coloring</span>
<span class="sd">    equitable_node_k_coloring</span>
<span class="sd">    edge_k_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: DSatur &lt;https://en.wikipedia.org/wiki/DSatur&gt;</span>
<span class="sd">    .. [2] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [3] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, nonnegative integer needed for k&quot;</span><span class="p">)</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">cliqueNum</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">approximation</span><span class="o">.</span><span class="n">large_clique_size</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">cliqueNum</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, a clique of size greater than k exists in the graph, so a k-coloring is not possible. Try increasing k&quot;</span>
        <span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">_getNodeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">_dsatur_equitable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opt_alg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, a k-coloring could not be found. Try changing the optimisation options or increasing k&quot;</span>
            <span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_dsatur</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opt_alg</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">_getEdgeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_reducecolors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, could not construct a k-coloring of this graph. Try increasing k or using more optimisation&quot;</span>
            <span class="p">)</span>
    <span class="c1"># If we are here we have a k-coloring</span>
    <span class="k">return</span> <span class="n">c</span></div>



<div class="viewcode-block" id="equitable_edge_k_coloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.equitable_edge_k_coloring">[docs]</a>
<span class="k">def</span> <span class="nf">equitable_edge_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempts to color the edges of a graph using ``k`` colors so that (a) adjacent edges have different colors, and (b) the weight of each color class is equal. (A pair of edges is considered adjacent if and only if they share a common endpoint.) If ``weight=None``, the weight of a color class is the number of edges assigned to that color; otherwise, it is the sum of the weights of the edges assigned to that color.</span>

<span class="sd">    Equivalently, this routine seeks to partition the graph&#39;s edges into $k$ matchings so that the weight of each matching is equal.</span>

<span class="sd">    This method first follows the steps used by the :meth:`edge_k_coloring` method to try and find an edge $k$-coloring. That is, edge colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$ and then passing $L(G)$ to the :meth:`node_k_coloring` method. All parameters are therefore the same as the latter. (Note that, if a graph $G=(V,E)$ has $n$ nodes and $m$ edges, its line graph $L(G)$ will have $m$ nodes and $\\frac{1}{2}\\sum_{v\\in V}\\deg(v)^2 - m$ edges.)</span>

<span class="sd">    If an edge $k$-coloring cannot be determined by the algorithm, a ``ValueError`` exception is raised. Otherwise, once an edge $k$-coloring has been formed, the algorithm uses a bespoke local search operator to reduce the variance in weights across the $k$ colors. In solutions returned by this method, adjacent edges always receive different colors; however, the coloring is not guaranteed to be equitable, even if an equitable edge $k$-coloring exists.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The edges of this graph will be colored.</span>

<span class="sd">    k : int</span>
<span class="sd">        The number of colors to use.</span>

<span class="sd">    weight : None or string, optional (default=None)</span>
<span class="sd">        If ``None``, every edge is assumed to have a weight of ``1``. If a string, this should correspond to a defined edge attribute. Edge weights must be positive.</span>

<span class="sd">    opt_alg : None or int, optional (default=None)</span>
<span class="sd">        An integer specifying the optimization method that will be used to try to reduce the number of colors (if this is seen to be greater than ``k``). It must be one of the following</span>

<span class="sd">        * ``1`` : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when the existence of an edge $k$-coloring has been proved or disproved.</span>
<span class="sd">        * ``2`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes in $L(G)$ to have the same color. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes in $L(G)$, $m$ is the number of edges in $L(G)$, and $k$ is the number of colors in the current solution.</span>
<span class="sd">        * ``3`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes in $L(G)$ to be uncolored. Each iteration has a complexity $O(m + kn)$, as above.</span>
<span class="sd">        * None : No optimization is performed.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Only applicable when using ``opt_alg=2`` or ``opt_alg=3``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots,k-1$.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.equitable_edge_k_coloring(G, 4)</span>
<span class="sd">    &gt;&gt;&gt; P = gcol.partition(c)</span>
<span class="sd">    &gt;&gt;&gt; print(P)</span>
<span class="sd">    [[(11, 12), (18, 19), (16, 17), (9, 10), (0, 1), (14, 15), (7, 8), (2, 6)], [(11, 18), (12, 13), (15, 16), (3, 19), (1, 8), (4, 5), (7, 14)], [(10, 11), (17, 18), (0, 19), (9, 13), (3, 4), (1, 2), (5, 15), (6, 7)], [(12, 16), (4, 17), (0, 10), (8, 9), (13, 14), (2, 3), (5, 6)]]</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Size of smallest color class =&quot;, min(len(j) for j in P))</span>
<span class="sd">    Size of smallest color class = 7</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Size of biggest color class =&quot;, max(len(j) for j in P))</span>
<span class="sd">    Size of biggest color class = 8</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; #Now add some (arbitrary) weights to the edges</span>
<span class="sd">    &gt;&gt;&gt; for e in G.edges():</span>
<span class="sd">    &gt;&gt;&gt;     G.add_edge(e[0], e[1], weight = abs(e[0]-e[1]))</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.equitable_edge_k_coloring(G, 5, weight=&quot;weight&quot;)</span>
<span class="sd">    &gt;&gt;&gt; P = gcol.partition(c)</span>
<span class="sd">    &gt;&gt;&gt; print(P)</span>
<span class="sd">    [[(11, 12), (18, 19), (4, 17), (13, 14), (1, 8), (2, 3)], [(11, 18), (9, 13), (0, 1), (3, 4), (5, 15), (7, 8)], [(10, 11), (17, 18), (15, 16), (0, 19), (1, 2), (6, 7)], [(12, 16), (9, 10), (3, 19), (14, 15), (5, 6)], [(12, 13), (16, 17), (0, 10), (8, 9), (4, 5), (7, 14), (2, 6)]]</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Weight of lightest color class =&quot;, min(sum(G[u][v][&quot;weight&quot;] for u, v in j) for j in P))</span>
<span class="sd">    Weight of lightest color class = 23</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Weight of heaviest color class =&quot;, max(sum(G[u][v][&quot;weight&quot;] for u, v in j) for j in P))</span>
<span class="sd">    Weight of heaviest color class = 25</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``opt_alg`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>
<span class="sd">        If ``k`` is not a nonnegative integer.</span>
<span class="sd">        If a clique larger than ``k`` is observed in the line graph of $G$.</span>
<span class="sd">        If ``k`` is less than the maximum degree in ``G``.</span>
<span class="sd">        If an edge $k$-coloring could not be determined.</span>
<span class="sd">        If an edge with a non-positive weight is specified.</span>

<span class="sd">    KeyError</span>
<span class="sd">        If an edge does not have the attribute defined by ``weight``</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As mentioned, in this implementation edge colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$ and then following the same steps as the :meth:`node_k_coloring` method to try and find a node $k$-coloring of $L(G)$; however, it also takes edge weights into account if needed. If an edge $k$-coloring is achieved, a bespoke local search operator (based on steepest descent) is then used to try to reduce the variance in weights across the $k$ color classes. This follows the same steps as the :meth:`equitable_node_k_coloring` method, using $L(G)$. Further details on this optimization method can be found in Chapter 7 of [2]_, or in [3]_.</span>

<span class="sd">    All the above algorithms are described in detail in [2]_. The c++ code used in [2]_ and [4]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    edge_k_coloring</span>
<span class="sd">    node_k_coloring</span>
<span class="sd">    equitable_node_k_coloring</span>
<span class="sd">    kempe_chain</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: Vizing&#39;s Theorem &lt;https://en.wikipedia.org/wiki/Vizing%27s_theorem&gt;</span>
<span class="sd">    .. [2] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [3] Lewis, R. and F. Carroll (2016) &#39;Creating Seating Plans: A Practical Application&#39;. Journal of the Operational Research Society, vol. 67(11), pp. 1353-1362.</span>
<span class="sd">    .. [4] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, nonnegative integer needed for k&quot;</span><span class="p">)</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">maxdeg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">maxdeg</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, a k-coloring of this graph does not exist. Try increasing k&quot;</span>
        <span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">H</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">H</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">equitable_node_k_coloring</span><span class="p">(</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="n">it_limit</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="edge_k_coloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.edge_k_coloring">[docs]</a>
<span class="k">def</span> <span class="nf">edge_k_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempts to color the edges of a graph ``G`` using ``k`` colors so that adjacent edges have different colors (a pair of edges is considered adjacent if and only if they share a common endpoint). A set of edges assigned to the same color corresponds to a matching; hence the equivalent aim is to partition the graph&#39;s edges into ``k`` matchings.</span>

<span class="sd">    The smallest number of colors needed for coloring the edges of a graph $G$ is known as the graph&#39;s chromatic index, denoted by $\\chi&#39;(G)$. Equivalently, $\\chi&#39;(G)$ is the minimum number of matchings needed to partition the nodes of a simple graph $G$. According to Vizing&#39;s theorem [1]_, $\\chi&#39;(G)$ is either $\\Delta(G)$ or $\\Delta(G) + 1$, where $\\Delta(G)$ is the maximum degree in $G$. The problem of determining an edge $k$-coloring is polynomially solvable for any $k &gt; \\Delta(G)$. Similarly, it is certain no edge $k$-coloring exists for $k &lt; \\Delta(G)$. For $k = \\Delta(G)$, however, the problem is NP-hard.</span>

<span class="sd">    This method therefore includes options for using an exact exponential-time algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for larger values of $k$, for graphs that are small, or graphs that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</span>

<span class="sd">    This method follows the steps used by the :meth:`node_k_coloring` method. That is, edge $k$-colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$ and then passing $L(G)$ to the :meth:`node_k_coloring` method. All parameters are therefore the same as the latter. (Note that, if a graph $G=(V,E)$ has $n$ nodes and $m$ edges, its line graph $L(G)$ will have $m$ nodes and $\\frac{1}{2}\\sum_{v\\in V}\\deg(v)^2 - m$ edges.)</span>

<span class="sd">    If an edge $k$-coloring cannot be determined by the algorithm, a ``ValueError`` exception is raised. Otherwise, an edge $k$-coloring is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The edges of this graph will be colored.</span>

<span class="sd">    k : int</span>
<span class="sd">        The number of colors to use.</span>

<span class="sd">    opt_alg : None or int, optional (default=None)</span>
<span class="sd">        An integer specifying the optimization method that will be used to try to reduce the number of colors (if this is seen to be greater than $k$). It must be one of the following</span>

<span class="sd">        * ``1`` : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when the existence of an edge $k$-coloring has been proved or disproved.</span>
<span class="sd">        * ``2`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes in $L(G)$ to have the same color. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes in $L(G)$, $m$ is the number of edges in $L(G)$, and $k$ is the number of colors in the current solution.</span>
<span class="sd">        * ``3`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes in $L(G)$ to be uncolored. Each iteration has a complexity $O(m + kn)$, as above.</span>
<span class="sd">        * ``None`` : No optimization is performed.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Only applicable when using ``opt_alg=2`` or ``opt_alg=3``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots,k-1$.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.edge_k_coloring(G, 4)</span>
<span class="sd">    &gt;&gt;&gt; print(c)</span>
<span class="sd">    {(11, 12): 0, (11, 18): 1, (10, 11): 2, (12, 16): 3, (12, 13): 1, (18, 19): 0, (17, 18): 2, (16, 17): 0, (4, 17): 3, (15, 16): 1, (0, 10): 3, (9, 10): 0, (0, 19): 2, (9, 13): 2, (3, 19): 1, (0, 1): 0, (8, 9): 3, (13, 14): 3, (3, 4): 2, (1, 8): 1, (14, 15): 0, (4, 5): 1, (2, 3): 3, (1, 2): 2, (7, 8): 0, (5, 15): 2, (7, 14): 1, (2, 6): 0, (5, 6): 3, (6, 7): 2}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.edge_k_coloring(G, 3)</span>
<span class="sd">    &gt;&gt;&gt; print(c)</span>
<span class="sd">    {(11, 12): 0, (11, 18): 1, (10, 11): 2, (12, 16): 1, (12, 13): 2, (18, 19): 0, (17, 18): 2, (16, 17): 0, (4, 17): 1, (15, 16): 2, (0, 10): 0, (9, 10): 1, (9, 13): 0, (8, 9): 2, (13, 14): 1, (14, 15): 0, (5, 15): 1, (7, 14): 2, (0, 19): 1, (3, 19): 2, (0, 1): 2, (3, 4): 0, (2, 3): 1, (1, 2): 0, (2, 6): 2, (5, 6): 0, (4, 5): 2, (1, 8): 1, (6, 7): 1, (7, 8): 0}</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``opt_alg`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>
<span class="sd">        If ``k`` is not a nonnegative integer.</span>
<span class="sd">        If a clique larger than ``k`` is observed in the line graph of $G$.</span>
<span class="sd">        If ``k`` is less than the maximum degree in ``G``.</span>
<span class="sd">        If an edge $k$-coloring could not be determined.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As mentioned, in this implementation, edge colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$ and then passing $L(G)$ to the :meth:`node_k_coloring` method. All details are therefore the same as those in the latter. The routine halts immediately once an edge $k$-coloring has been achieved.</span>

<span class="sd">    All the above algorithms and bounds are described in detail in [2]_. The c++ code used in [2]_ and [3]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    edge_coloring</span>
<span class="sd">    equitable_edge_k_coloring</span>
<span class="sd">    node_k_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: Vizing&#39;s Theorem &lt;https://en.wikipedia.org/wiki/Vizing%27s_theorem&gt;</span>
<span class="sd">    .. [2] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [3] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, positive integer needed for k&quot;</span><span class="p">)</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">maxdeg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">maxdeg</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error, a k-coloring of this graph does not exist. Try increasing k&quot;</span>
        <span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node_k_coloring</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="n">it_limit</span><span class="p">)</span></div>



<div class="viewcode-block" id="node_coloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.node_coloring">[docs]</a>
<span class="k">def</span> <span class="nf">node_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a coloring of a graph&#39;s nodes.</span>

<span class="sd">    A node coloring of a graph is an assignment of colors to nodes so that adjacent nodes have different colors. The aim is to use as few colors as possible. A set of nodes assigned to the same color represents an independent set; hence the equivalent aim is to partition the graph&#39;s nodes into a minimum number of independent sets.</span>

<span class="sd">    The smallest number of colors needed to color the nodes of a graph $G$ is known as the graph&#39;s chromatic number, denoted by $\\chi(G)$. Equivalently, $\\chi(G)$ is the minimum number of independent sets needed to partition the nodes of $G$.</span>

<span class="sd">    Determining a node coloring that minimizes the number of colors is an NP-hard problem. This method therefore includes options for using an exact exponential-time algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for graphs that are small, or that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The nodes of this graph will be colored.</span>

<span class="sd">    strategy : string, optional (default=&#39;dsatur&#39;)</span>
<span class="sd">        A string specifying the method used to generate an initial solution. It must be one of the following:</span>

<span class="sd">        * ``&#39;random&#39;`` : Randomly orders the graph&#39;s nodes and then applies the greedy algorithm for graph node coloring [1]_.</span>
<span class="sd">        * ``&#39;welsh-powell&#39;`` : Orders the graph&#39;s nodes by decreasing degree, then applies the greedy algorithm.</span>
<span class="sd">        * ``&#39;dsatur&#39;`` : Uses the DSatur algorithm for graph node coloring [2]_.</span>
<span class="sd">        * ``&#39;rlf&#39;`` : Uses the recursive largest first (RLF) algorithm for graph node coloring [3]_.</span>

<span class="sd">    opt_alg : None or int, optional (default=None)</span>
<span class="sd">        An integer specifying the optimization method that will be used to try to reduce the number of colors. It must be one of the following</span>

<span class="sd">        * ``1`` : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when an optimal solution has been found.</span>
<span class="sd">        * ``2`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes to have the same color. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes in the graph, $m$ is the number of edges, and $k$ is the number of colors in the current solution.</span>
<span class="sd">        * 3 : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes to be uncolored. Each iteration has a complexity $O(m + kn)$, as above.</span>
<span class="sd">        * None : No optimization is performed.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Only applicable when using ``opt_alg=2`` or ``opt_alg=3``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$. The number of colors being used in a solution ``c`` is therefore ``max(c.values()) + 1``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Coloring is&quot;, c)</span>
<span class="sd">    Coloring is {0: 0, 1: 1, 19: 1, 10: 1, 2: 0, 3: 2, 8: 0, 9: 2, 18: 0, 11: 2, 6: 1, 7: 2, 4: 0, 5: 2, 13: 0, 12: 1, 14: 1, 15: 0, 16: 2, 17: 1}</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Number of colors =&quot;, max(c.values()) + 1)</span>
<span class="sd">    Number of colors = 3</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Partition view =&quot;, gcol.partition(c))</span>
<span class="sd">    Partition view = [[0, 2, 8, 18, 4, 13, 15], [1, 19, 10, 6, 12, 14, 17], [3, 9, 11, 7, 5, 16]]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example with a larger graph and different parameters</span>
<span class="sd">    &gt;&gt;&gt; G = nx.gnp_random_graph(50, 0.2, seed=1)</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_coloring(G, strategy=&quot;dsatur&quot;, opt_alg=2, it_limit=1000)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Coloring is&quot;, c)</span>
<span class="sd">    Coloring is {18: 0, 31: 2, 2: 4, 20: 1, 10: 3, 46: 0, 49: 1, 29: 3, 37: 2, 9: 1, 7: 2, 33: 0, 21: 4, 26: 2, 5: 4, 16: 0, 41: 1, 39: 0, 13: 3, 14: 4, 17: 3, 28: 0, 35: 1, 42: 4, 4: 4, 11: 3, 3: 2, 48: 3, 40: 3, 0: 0, 30: 0, 6: 2, 8: 3, 25: 1, 34: 0, 44: 3, 24: 1, 1: 4, 47: 4, 15: 1, 23: 4, 32: 4, 45: 0, 22: 1, 43: 4, 36: 2, 19: 3, 12: 3, 38: 1, 27: 2}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Number of colors =&quot;, max(c.values()) + 1)</span>
<span class="sd">    Number of colors = 5</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``strategy`` is not among the supported options.</span>
<span class="sd">        If ``opt_alg`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a graph $G=(V,E)$ with $n$ nodes and $m$ edges, the greedy algorithm for node coloring operates in $O(n + m)$ time.</span>

<span class="sd">    The ``random`` strategy operates by first randomly permuting the nodes (an $O(n)$ operation) before applying the greedy algorithm. It is guaranteed to produce a solution with $k \\leq \\Delta(G) + 1$ colors, where $\\Delta(G)$ is the highest node degree in the graph $G$.</span>

<span class="sd">    The ``welsh-powell`` strategy operates by sorting the nodes by decreasing degree (an $O(n \\lg n)$ operation), and then applies the greedy algorithm. Its overall complexity is therefore $O(n \\lg n + m)$. Assuming that the nodes are labelled $v_1, v_2,\\ldots,v_n$ so that $\\deg(v_1) \\geq \\deg(v_2) \\geq \\ldots \\geq \\deg(v_n)$, this method is guaranteed to produce a solution with $k \\leq\\max_{i=1,\\ldots,n} \\min(\\deg(v_i)+1, i)$ colors. This bound is an improvement on $\\Delta(G) + 1$.</span>

<span class="sd">    The ``dsatur`` and ``rlf`` strategies are exact for bipartite, cycle, and wheel graphs (that is, solutions with the minimum number of colors are guaranteed). The implementation of ``dsatur`` uses a priority queue and has a complexity of $O(n \\lg n + m \\lg m)$. The ``rlf`` implementation has a complexity of $O(nm)$. In general, the ``rlf`` strategy yields the best solutions of the four strategies, though it is computationally more expensive. If expense is an issue, then ``dsatur`` is a cheaper alternative that also offers high-quality solutions in most cases. See [2]_, [3]_, and [4]_ for further information.</span>

<span class="sd">    If an optimization algorithm is used, further efforts are made to reduce the number of colors. The backtracking approach (``opt_alg=1``) is an implementation of the exact algorithm described in [4]_. It has exponential runtime and halts only when an optimum solution has been found. At the start of execution, a large clique $C\\subseteq V$ is identified using the NetworkX function ``max_clique(G)`` and the nodes of $C$ are each assigned to a different color. The main backtracking algorithm is then executed and only halts only when a solution using $|C|$ colors has been identified, or when the algorithm has backtracked to the root of the search tree. In both cases the returned solution will be optimal (that is, will be using $\\chi(G)$ colors).</span>

<span class="sd">    If local search is used (``opt_alg=2`` or ``opt_alg=3``), the algorithm removes a color class and uses the chosen local search routine to seek a proper coloring using the remaining colors. If this is successful, the process repeats. The algorithm is executed until a solution using $|C|$ colors has been identified (as above), or until the iteration limit is reached. Fewer colors (but longer run times) occur with larger iteration limits.</span>

<span class="sd">    If ``opt_alg=2``, the TabuCol algorithm is used. This algorithm is based on tabu search and operates by fixing the number of colors but allowing clashes to occur (a clash is the occurrence of two adjacent nodes having the same color). The aim is to alter the color assignments so that the number of clashes is reduced to zero. Each iteration of TabuCol has complexity $O(nk + m)$, where $k$ is the number of colors currently being used. The process also uses $O(nk + m)$ memory.</span>

<span class="sd">    If ``opt_alg=3``, the PartialCol algorithm is used. This algorithm is also based on tabu search and operates by fixing the number of colors but allowing some nodes to be left uncolored. The aim is to make alterations to the color assignments so that no uncolored nodes remain. As with TabuCol, each iteration of PartialCol has complexity $O(nk +m)$ and uses $O(nk + m)$ memory.</span>

<span class="sd">    All the above algorithms and bounds are described in detail in [4]_. The c++ code used in [4]_ and [5]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chromatic_number</span>
<span class="sd">    node_k_coloring</span>
<span class="sd">    edge_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: Greedy Coloring &lt;https://en.wikipedia.org/wiki/Greedy_coloring&gt;</span>
<span class="sd">    .. [2] Wikipedia: DSatur &lt;https://en.wikipedia.org/wiki/DSatur&gt;</span>
<span class="sd">    .. [3] Wikipedia: Recursive largest first (RLF) algorithm &lt;https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm&gt;</span>
<span class="sd">    .. [4] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [5] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">}</span>
    <span class="c1"># Make an initial coloring based on the chosen strategy</span>
    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_greedy</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;welsh_powell&quot;</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_greedy</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;rlf&quot;</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_rlf</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_dsatur</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="c1"># If selected, employ the chosen optimisation method</span>
    <span class="k">if</span> <span class="n">opt_alg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">opt_alg</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">_getEdgeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">_getNodeWeights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">cliqueNum</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">approximation</span><span class="o">.</span><span class="n">large_clique_size</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nc</span><span class="o">.</span><span class="n">_reducecolors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cliqueNum</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span></div>



<div class="viewcode-block" id="edge_coloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.edge_coloring">[docs]</a>
<span class="k">def</span> <span class="nf">edge_coloring</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a coloring of a graph&#39;s edges.</span>

<span class="sd">    An edge coloring of a graph is an assignment of colors to edges so that adjacent edges have different colors (a pair of edges is considered adjacent if and only if they share a common endpoint). The aim is to use as few colors as possible. A set of edges assigned to the same color corresponds to a matching; hence the equivalent aim is to partition the graph&#39;s edges into a minimum number of matchings.</span>

<span class="sd">    The smallest number of colors needed for coloring the edges of a graph $G$ is known as the graph&#39;s chromatic index, denoted by $\\chi&#39;(G)$. Equivalently, $\\chi&#39;(G)$ is the minimum number of matchings needed to partition the nodes of a simple graph $G$. According to Vizing&#39;s theorem [1]_, $\\chi&#39;(G)$ is either $\\Delta(G)$ or $\\Delta(G) + 1$, where $\\Delta(G)$ is the maximum degree in $G$.</span>

<span class="sd">    Determining an edge coloring that minimizes the number of colors is an NP-hard problem. This method therefore includes options for using an exponential-time exact algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for graphs that are small, or that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</span>

<span class="sd">    In this implementation, edge colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$, and then passing $L(G)$ to the :meth:`node_coloring` method. All parameters are therefore the same as the latter. (Note that, if a graph $G=(V,E)$ has $n$ nodes and $m$ edges, its line graph $L(G)$ will have $m$ nodes and $\\frac{1}{2}\\sum_{v\\in V}\\deg(v)^2 - m$ edges.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The edges of this graph will be colored.</span>

<span class="sd">    strategy: string, optional (default=&#39;dsatur&#39;)</span>
<span class="sd">        A string specifying the method used to generate the initial solution. It must be one of the following:</span>

<span class="sd">        * ``&#39;random&#39;`` : Randomly orders $L(G)$&#39;s nodes and then applies the greedy algorithm for graph node coloring [2]_.</span>
<span class="sd">        * ``&#39;welsh-powell&#39;`` : Orders $L(G)$&#39;s nodes by decreasing degree, then applies the greedy algorithm.</span>
<span class="sd">        * ``&#39;dsatur&#39;`` : Uses the DSatur algorithm for graph node coloring on $L(G)$ [3]_.</span>
<span class="sd">        * ``&#39;rlf&#39;`` : Uses the recursive largest first (RLF) algorithm for graph node coloring on $L(G)$ [4]_.</span>

<span class="sd">    opt_alg : None or int, optional (default=None)</span>
<span class="sd">        An integer specifying the optimization method that will be used to try to reduce the number of colors. It must be one of the following</span>

<span class="sd">        * ``1`` : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when an optimal solution has been found.</span>
<span class="sd">        * ``2`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes in $L(G)$ to have the same color. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes in $L(G)$, $m$ is the number of edges in $L(G)$, and $k$ is the number of colors in the current solution.</span>
<span class="sd">        * ``3`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes in $L(G)$ to be uncolored. Each iteration has a complexity $O(m + kn)$, as above.</span>
<span class="sd">        * ``None`` : No optimization is performed.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Only applicable when using ``opt_alg=2`` or ``opt_alg=3``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$. The number of colors being used in a solution ``c`` is therefore ``max(c.values()) + 1``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.edge_coloring(G)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Coloring is&quot;, c)</span>
<span class="sd">    Coloring is {(11, 12): 0, (11, 18): 1, (10, 11): 2, (12, 16): 1, (12, 13): 2, (18, 19): 0, (17, 18): 2, (16, 17): 0, (4, 17): 1, (15, 16): 2, (0, 10): 0, (9, 10): 1, (9, 13): 0, (8, 9): 2, (13, 14): 1, (14, 15): 0, (5, 15): 1, (7, 14): 2, (0, 19): 1, (3, 19): 2, (0, 1): 2, (3, 4): 0, (2, 3): 1, (1, 2): 0, (2, 6): 2, (5, 6): 0, (4, 5): 2, (1, 8): 1, (6, 7): 1, (7, 8): 0}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Number of colors =&quot;, max(c.values()) + 1)</span>
<span class="sd">    Number of colors = 3</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.edge_coloring(G, strategy=&quot;rlf&quot;, opt_alg=2, it_limit=1000)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Coloring is&quot;, c)</span>
<span class="sd">    Coloring is {(3, 4): 0, (17, 18): 0, (0, 19): 0, (10, 11): 0, (12, 16): 0, (5, 15): 0, (13, 14): 0, (8, 9): 0, (1, 2): 0, (6, 7): 0, (16, 17): 1, (4, 5): 1, (14, 15): 1, (2, 6): 1, (3, 19): 1, (11, 18): 1, (12, 13): 1, (9, 10): 1, (0, 1): 1, (7, 8): 1, (18, 19): 2, (5, 6): 2, (4, 17): 2, (0, 10): 2, (9, 13): 2, (1, 8): 2, (15, 16): 2, (11, 12): 2, (2, 3): 2, (7, 14): 2}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Number of colors =&quot;, max(c.values()) + 1)</span>
<span class="sd">    Number of colors = 3</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``strategy`` is not among the supported options.</span>
<span class="sd">        If ``opt_alg`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As mentioned, in this implementation, edge colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$ and then passing $L(G)$ to the :meth:`node_coloring` method. All details are therefore the same as those in the latter, where they are documented more fully.</span>

<span class="sd">    All the above algorithms and bounds are described in detail in [5]_. The c++ code used in [5]_ and [6]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    node_coloring</span>
<span class="sd">    chromatic_index</span>
<span class="sd">    edge_k_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: Vizing&#39;s Theorem &lt;https://en.wikipedia.org/wiki/Vizing%27s_theorem&gt;</span>
<span class="sd">    .. [2] Wikipedia: Greedy Coloring &lt;https://en.wikipedia.org/wiki/Greedy_coloring&gt;</span>
<span class="sd">    .. [3] Wikipedia: DSatur &lt;https://en.wikipedia.org/wiki/DSatur&gt;</span>
<span class="sd">    .. [4] Wikipedia: Recursive largest first (RLF) algorithm &lt;https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm&gt;</span>
<span class="sd">    .. [5] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [6] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="c1"># Now simply color the nodes of the line graph H of G</span>
    <span class="n">maxdeg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_greedy</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;welsh_powell&quot;</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">H</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_greedy</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;rlf&quot;</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_rlf</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_dsatur</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="c1"># If selected, employ the chosen optimisation method</span>
    <span class="k">if</span> <span class="n">opt_alg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">opt_alg</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">_getEdgeWeights</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">_getNodeWeights</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">cliqueNum</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">approximation</span><span class="o">.</span><span class="n">large_clique_size</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nc</span><span class="o">.</span><span class="n">_reducecolors</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">cliqueNum</span><span class="p">,</span> <span class="n">maxdeg</span><span class="p">),</span> <span class="n">W</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span></div>



<div class="viewcode-block" id="chromatic_number">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.chromatic_number">[docs]</a>
<span class="k">def</span> <span class="nf">chromatic_number</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the chromatic number of the graph ``G``.</span>

<span class="sd">    The chromatic number of a graph $G$ is the minimum number of colors needed to color the nodes so that no two adjacent nodes have the same color. It is commonly denoted by $\\chi(G)$. Equivalently, $\\chi(G)$ is the minimum number of independent sets needed to partition the nodes of $G$.</span>

<span class="sd">    Determining the chromatic number is NP-hard. The approach used here is based on the backtracking algorithm of [1]_. This is exact but operates in exponential time. It is therefore only suitable for graphs that are small, or that have topologies suited to its search strategies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The chromatic number for this graph will be calculated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        A nonnegative integer that gives the chromatic number of ``G``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; chi = gcol.chromatic_number(G)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Chromatic number is&quot;, chi)</span>
<span class="sd">    Chromatic number is 3</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The backtracking approach used here is an implementation of the exact algorithm described in [1]_. It has exponential runtime and halts only when the chromatic number has been determined. Further details of this algorithm are given in the notes section of the :meth:`node_coloring` method.</span>

<span class="sd">    The above algorithm is described in detail in [1]_. The c++ code used in [1]_ and [2]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chromatic_index</span>
<span class="sd">    node_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [2] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Error, this method cannot be used with directed graphs or multigraphs&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">cliqueNum</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">approximation</span><span class="o">.</span><span class="n">large_clique_size</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_backtrackcol</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cliqueNum</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="chromatic_index">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.chromatic_index">[docs]</a>
<span class="k">def</span> <span class="nf">chromatic_index</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the chromatic index of the graph ``G``.</span>

<span class="sd">    The chromatic index of a graph $G$ is the minimum number of colors needed to color the edges so that no two adjacent edges have the same color (a pair of edges is considered adjacent if and only if they share a common endpoint). The chromatic index is commonly denoted by $\\chi&#39;(G)$. Equivalently, $\\chi&#39;(G)$ is the minimum number of matchings needed to partition the edges of $G$. According to Vizing&#39;s theorem [1]_, $\\chi&#39;(G)$ is equal to either $\\Delta(G)$ or $\\Delta(G) + 1$, where $\\Delta(G)$ is the maximum degree in $G$.</span>

<span class="sd">    Determining the chromatic index of a graph is NP-hard. The approach used here is based on the backtracking algorithm of [2]_. This is exact but operates in exponential time. It is therefore only suitable for graphs that are small, or that have topologies suited to its search strategies.</span>

<span class="sd">    In this implementation, edge colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$ and then passing $L(G)$ to the :meth:`chromatic_number` method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The chromatic index for this graph will be calculated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        A nonnegative integer that gives the chromatic index of ``G``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; chi = gcol.chromatic_index(G)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Chromatic index is&quot;, chi)</span>
<span class="sd">    Chromatic index is 3</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The backtracking approach used here is an implementation of the exact algorithm described in [2]_. It has exponential runtime and halts only when the chromatic index has been determined. Further details of this algorithm are given in the notes section of the :meth:`node_coloring` method.</span>

<span class="sd">    The above algorithm is described in detail in [2]_. The c++ code used in [2]_ and [3]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    chromatic_number</span>
<span class="sd">    node_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: Vizing&#39;s Theorem &lt;https://en.wikipedia.org/wiki/Vizing%27s_theorem&gt;</span>
<span class="sd">    .. [2] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [3] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Error, this method cannot be used with directed graphs or multigraphs&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">maxdeg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">cliqueNum</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">approximation</span><span class="o">.</span><span class="n">large_clique_size</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">_backtrackcol</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">cliqueNum</span><span class="p">,</span> <span class="n">maxdeg</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span></div>



<div class="viewcode-block" id="node_precoloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.node_precoloring">[docs]</a>
<span class="k">def</span> <span class="nf">node_precoloring</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span> <span class="n">precol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a coloring of a graph&#39;s nodes in which some of the nodes have been precolored.</span>

<span class="sd">    A node coloring of a graph is an assignment of colors to nodes so that adjacent nodes have different colors. The aim is to use as few colors as possible. A set of nodes assigned to the same color corresponds to an independent set; hence the equivalent aim is to partition the graph&#39;s nodes into a minimum number of independent sets.</span>

<span class="sd">    In the node precoloring problem, some of the nodes have already been assigned colors. The aim is to allocate colors to the remaining nodes so that we get a full, proper node coloring that uses a minimum number of colors. The node precoloring problem can be used to model the Latin square completion problem and Sudoku puzzles [1]_.</span>

<span class="sd">    The node precoloring problem is NP-hard. This method therefore includes options for using an exponential-time exact algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for graphs that are small, or that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</span>

<span class="sd">    In this implementation, solutions are found by taking all nodes pre-allocated to the same color $j$ and merging them into a single super-node. Edges are then added between all pairs of super-nodes, and the modified graph is passed to the :meth:`node_coloring` method. All parameters are therefore the same as the latter. This modification process is described in more detail in Chapter 6 of [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The nodes of this graph will be colored.</span>

<span class="sd">    precol : None or dict, optional (default=None)</span>
<span class="sd">        A dictionary that specifies the (integer) colors of any precolored nodes.</span>

<span class="sd">    strategy : string, optional (default=&#39;dsatur&#39;)</span>
<span class="sd">        A string specifying the method used to generate the initial solution. It must be one of the following:</span>

<span class="sd">        * ``&#39;random&#39;`` : Randomly orders the modified graph&#39;s nodes and then applies the greedy algorithm for graph node coloring [2]_.</span>
<span class="sd">        * ``&#39;welsh-powell&#39;`` : Orders the modified graphs nodes by decreasing degree, then applies the greedy algorithm.</span>
<span class="sd">        * ``&#39;dsatur&#39;`` : Uses the DSatur algorithm for graph node coloring on the modified graph [3]_.</span>
<span class="sd">        * ``&#39;rlf&#39;`` : Uses the recursive largest first (RLF) algorithm for graph node coloring on the modified graph [4]_.</span>

<span class="sd">    opt_alg : None or int, optional (default=None)</span>
<span class="sd">        An integer specifying the optimization method that will be used to try to reduce the number of colors. It must be one of the following</span>

<span class="sd">        * ``1`` : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when an optimal solution has been found.</span>
<span class="sd">        * ``2`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes to have the same color. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes in the modified graph, $m$ is the number of edges, and $k$ is the number of colors in the current solution.</span>
<span class="sd">        * ``3`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes to be uncolored. Each iteration has a complexity $O(m + kn)$, as above.</span>
<span class="sd">        * ``None`` : No optimization is performed.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Only applicable when using ``opt_alg=2`` or ``opt_alg=3``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing nodes and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$. The number of colors being used in a solution ``c`` is therefore ``max(c.values()) + 1``. If ``precol[v]==j`` then ``c[v]==j``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; p = {0:1, 8:0, 9:1}</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_precoloring(G, precol=p)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Coloring is&quot;, c)</span>
<span class="sd">    Coloring is {0: 1, 9: 1, 1: 2, 8: 0, 19: 2, 13: 2, 2: 1, 3: 0, 7: 1, 14: 0, 18: 1, 12: 1, 6: 2, 4: 1, 5: 0, 15: 1, 11: 2, 10: 0, 17: 2, 16: 0}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; p = {i:i for i in range(5)}</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.node_precoloring(G, precol=p, strategy=&quot;dsatur&quot;, opt_alg=2, it_limit=1000)</span>
<span class="sd">    &gt;&gt;&gt; print(c)</span>
<span class="sd">    {0: 0, 4: 4, 1: 1, 2: 2, 3: 3, 19: 4, 10: 4, 5: 0, 6: 4, 17: 0, 18: 1, 11: 0, 8: 0, 7: 1, 9: 1, 15: 4, 14: 0, 16: 1, 13: 4, 12: 2}</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``strategy`` is not among the supported options.</span>
<span class="sd">        If ``opt_alg`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>
<span class="sd">        If ``G`` contains a node with the name ``&#39;super&#39;``.</span>
<span class="sd">        If ``precol`` contains a node that is not in ``G``.</span>
<span class="sd">        If ``precol`` contains a non-integer color label.</span>
<span class="sd">        If ``precol`` contains a pair of adjacent nodes assigned the same color.</span>
<span class="sd">        If ``precol`` uses an integer color label $j$, but there exists a color label $0 \\leq i &lt; j$ that is not being used.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As mentioned, in this implementation, solutions are formed by passing a modified version of the graph to :meth:`node_coloring` method. All details are therefore the same as those in the latter, where they are documented.</span>

<span class="sd">    All the above algorithms and bounds are described in detail in [1]. The c++ code used in [1]_ and [5]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    node_coloring</span>
<span class="sd">    edge_precoloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [2] Wikipedia: Greedy Coloring &lt;https://en.wikipedia.org/wiki/Greedy_coloring&gt;</span>
<span class="sd">    .. [3] Wikipedia: DSatur &lt;https://en.wikipedia.org/wiki/DSatur&gt;</span>
<span class="sd">    .. [4] Wikipedia: Recursive largest first (RLF) algorithm &lt;https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm&gt;</span>
<span class="sd">    .. [5] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">precol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">precol</span> <span class="o">==</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="n">node_coloring</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="n">it_limit</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precol</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Error, the precoloring should be a dict that assigns a subset of the graph&#39;s nodes to colors&quot;</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;super&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, for this method, the node name &#39;super&#39; is reserved. Please use another node name&quot;</span>
            <span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">precol</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, a node is defined in the precoloring that is not in the graph&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precol</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, all color labels in the precoloring should be integers&quot;</span>
            <span class="p">)</span>
        <span class="n">cols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">precol</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">precol</span> <span class="ow">and</span> <span class="n">precol</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">precol</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Error, there are adjacent nodes in the precoloring with the same color&quot;</span>
                <span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">precol</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, the color labels in the precoloring should be in {0,1,2,...} and each color should be being used by at least one node&quot;</span>
            <span class="p">)</span>
    <span class="c1"># V[i] holds the set of nodes assigned to each color i</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">precol</span><span class="p">:</span>
        <span class="n">V</span><span class="p">[</span><span class="n">precol</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1"># Form the graph GPrime. This incorporates the precolorings on G and</span>
    <span class="c1"># merges nodes of the same color into a single super-node</span>
    <span class="n">GPrime</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
        <span class="n">GPrime</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="s2">&quot;super&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">precol</span><span class="p">:</span>
            <span class="n">GPrime</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span> <span class="ow">and</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">GPrime</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">GPrime</span><span class="p">:</span>
                <span class="n">GPrime</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">GPrime</span><span class="p">:</span>
                    <span class="n">GPrime</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s2">&quot;super&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">GPrime</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s2">&quot;super&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;super&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
    <span class="c1"># Now color GPrime and use this solution to gain a coloring c for G</span>
    <span class="n">cPrime</span> <span class="o">=</span> <span class="n">node_coloring</span><span class="p">(</span>
        <span class="n">GPrime</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="n">it_limit</span>
    <span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cPrime</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">cPrime</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;super&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">cPrime</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cPrime</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
    <span class="c1"># Finally, apply a color relabeling to conform to the original precoloring</span>
    <span class="n">colmap</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">precol</span><span class="p">:</span>
        <span class="n">colmap</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span> <span class="o">=</span> <span class="n">precol</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">colmap</span><span class="p">:</span>
            <span class="n">colmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
        <span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">colmap</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">c</span></div>



<div class="viewcode-block" id="edge_precoloring">
<a class="viewcode-back" href="../../modules.html#gcol.coloring.edge_precoloring">[docs]</a>
<span class="k">def</span> <span class="nf">edge_precoloring</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span> <span class="n">precol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;dsatur&quot;</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="mi">0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a coloring of a graph&#39;s edges in which some of the edges have been precolored.</span>

<span class="sd">    An edge coloring of a graph is an assignment of colors to edges so that adjacent edges have different colors (a pair of edges is considered adjacent if and only if they share a common endpoint). The aim is to use as few colors as possible. A set of edges assigned to the same color corresponds to a matching; hence the equivalent aim is to partition the graph&#39;s edges into a minimum number of matchings.</span>

<span class="sd">    In the edge precoloring problem, some of the edges have already been assigned colors. The aim is to allocate colors to the remaining edges so that we get a full edge coloring that uses a minimum number of colors.</span>

<span class="sd">    The edge precoloring problem is NP-hard. This method therefore includes options for using an exponential-time exact algorithm (based on backtracking), or a choice of two polynomial-time heuristic algorithms (based on local search). The exact algorithm is generally only suitable for graphs that are small, or that have topologies suited to its search strategies. In all other cases, the local search algorithms are more appropriate.</span>

<span class="sd">    In this implementation, edge colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$ and then passing $L(G)$ to the :meth:`node_precoloring` method. All parameters are therefore the same as the latter. (Note that, if a graph $G=(V,E)$ has $n$ nodes and $m$ edges, its line graph $L(G)$ will have $m$ nodes and $\\frac{1}{2}\\sum_{v\\in V}\\deg(v)^2 - m$ edges.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The edges of this graph will be colored.</span>

<span class="sd">    precol : None or dict, optional (default=None)</span>
<span class="sd">        A dictionary that specifies the colors of any precolored edges.</span>

<span class="sd">    strategy : string, optional (default=&#39;dsatur&#39;)</span>
<span class="sd">        A string specifying the method used to generate the initial solution. It must be one of the following:</span>

<span class="sd">        * ``&#39;random&#39;`` : Randomly orders $L(G)$&#39;s nodes and then applies the greedy algorithm for graph node coloring [1]_.</span>
<span class="sd">        * ``&#39;welsh-powell&#39;`` : Orders $L(G)$&#39;s nodes by decreasing degree, then applies the greedy algorithm.</span>
<span class="sd">        * ``&#39;dsatur&#39;`` : Uses the DSatur algorithm for graph node coloring on $L(G)$ [2]_.</span>
<span class="sd">        * ``&#39;rlf&#39;`` : Uses the recursive largest first (RLF) algorithm for graph node coloring on $L(G)$ [3]_.</span>

<span class="sd">    opt_alg : None or int, optional (default=None)</span>
<span class="sd">        An integer specifying the optimization method that will be used to try to reduce the number of colors. It must be one of the following</span>

<span class="sd">        * ``1`` : An exact, exponential-time algorithm based on backtracking. The algorithm halts only when an optimal solution has been found.</span>
<span class="sd">        * ``2`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing adjacent nodes in $L(G)$ to have the same color. Each iteration has a complexity $O(m + kn)$, where $n$ is the number of nodes in $L(G)$, $m$ is the number of edges, and $k$ is the number of colors in the current solution.</span>
<span class="sd">        * ``3`` : A local search algorithm that seeks to reduce the number of colors by temporarily allowing nodes in $L(G)$ to be uncolored. Each iteration has a complexity $O(m + kn)$, as above.</span>
<span class="sd">        * ``None`` : No optimization is performed.</span>

<span class="sd">    it_limit : int, optional (default=0)</span>
<span class="sd">        Number of iterations of the local search procedure. Only applicable when using ``opt_alg=2`` or ``opt_alg=3``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with keys representing edges and values representing their colors. Colors are identified by the integers $0,1,2,\\ldots$. The number of colors being used in a solution ``c`` is therefore ``max(c.values()) + 1``. If ``precol[(u,v)]==j`` then ``c[(u,v)]==j``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">    &gt;&gt;&gt; import gcol</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; G = nx.dodecahedral_graph()</span>
<span class="sd">    &gt;&gt;&gt; p = {(0, 1):0, (8, 9): 1, (10, 11): 2, (11, 12): 3}</span>
<span class="sd">    &gt;&gt;&gt; c = gcol.edge_precoloring(G, precol=p)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Coloring is&quot;,c)</span>
<span class="sd">    Coloring is {(0, 1): 0, (8, 9): 1, (10, 11): 2, (11, 12): 3, (1, 8): 2, (0, 10): 1, (9, 10): 0, (11, 18): 0, (7, 8): 0, (1, 2): 1, (0, 19): 2, (9, 13): 2, (18, 19): 1, (12, 13): 0, (17, 18): 2, (3, 19): 0, (12, 16): 1, (13, 14): 1, (2, 3): 2, (16, 17): 0, (7, 14): 2, (3, 4): 1, (4, 17): 3, (2, 6): 0, (15, 16): 2, (14, 15): 0, (6, 7): 1, (4, 5): 0, (5, 15): 1, (5, 6): 2}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;Number of colors =&quot;, max(c.values()) + 1)</span>
<span class="sd">    Number of colors = 4</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If ``G`` is a directed graph or a multigraph.</span>

<span class="sd">    ValueError</span>
<span class="sd">        If ``strategy`` is not among the supported options.</span>
<span class="sd">        If ``opt_alg`` is not among the supported options.</span>
<span class="sd">        If ``it_limit`` is not a nonnegative integer.</span>
<span class="sd">        If ``precol`` contains an edge that is not in ``G``.</span>
<span class="sd">        If ``precol`` contains a non-integer color label.</span>
<span class="sd">        If ``precol`` contains a pair of adjacent edges assigned to the same color.</span>
<span class="sd">        If ``precol`` uses an integer color label $j$, but there exists a color label $0 \\leq i &lt; j$ that is not being used.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As mentioned, in this implementation, edge colorings of a graph $G$ are determined by forming $G$&#39;s line graph $L(G)$ and then passing $L(G)$ to the :meth:`node_precoloring` method. All details are therefore the same as those in the latter, where they are documented.</span>

<span class="sd">    All the above algorithms and bounds are described in detail in [4]_. The c++ code used in [4]_ and [5]_ forms the basis of this library&#39;s Python implementations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    edge_coloring</span>
<span class="sd">    node_precoloring</span>
<span class="sd">    node_coloring</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia: Greedy Coloring &lt;https://en.wikipedia.org/wiki/Greedy_coloring&gt;</span>
<span class="sd">    .. [2] Wikipedia: DSatur &lt;https://en.wikipedia.org/wiki/DSatur&gt;</span>
<span class="sd">    .. [3] Wikipedia: Recursive largest first (RLF) algorithm &lt;https://en.wikipedia.org/wiki/Recursive_largest_first_algorithm&gt;</span>
<span class="sd">    .. [4] Lewis, R. (2021) A Guide to Graph Colouring: Algorithms and Applications (second ed.). Springer. ISBN: 978-3-030-81053-5. &lt;https://link.springer.com/book/10.1007/978-3-030-81054-2&gt;.</span>
<span class="sd">    .. [5] Lewis, R: Graph Colouring Algorithm User Guide &lt;https://rhydlewis.eu/gcol/&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_params</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">precol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">precol</span> <span class="o">==</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="n">edge_coloring</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="n">it_limit</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precol</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Error, the precoloring should be a dict that assigns a subset of the graph&#39;s edges to colors&quot;</span>
        <span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">precol</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, an edge is defined in the precoloring that is not in the graph&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precol</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, all color labels in the precoloring should be integers&quot;</span>
            <span class="p">)</span>
        <span class="n">cols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">precol</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">precol</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">precol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e1</span> <span class="o">!=</span> <span class="n">e2</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">e2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="n">precol</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span> <span class="o">==</span> <span class="n">precol</span><span class="p">[</span><span class="n">e2</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Error, there are adjacent edges in the precoloring with the same color&quot;</span>
                        <span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">precol</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error, the color labels in the precoloring should be in {0,1,2,...} and each color should be being used by at least one edge&quot;</span>
            <span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node_precoloring</span><span class="p">(</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">precol</span><span class="o">=</span><span class="n">precol</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">opt_alg</span><span class="o">=</span><span class="n">opt_alg</span><span class="p">,</span> <span class="n">it_limit</span><span class="o">=</span><span class="n">it_limit</span>
    <span class="p">)</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">GCol 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gcol.coloring</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, R. Lewis.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>